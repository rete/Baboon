  /// \file myProc.cc
/*
 *
 * myProc.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "myProc.hh"


myProc aMyProc;


using namespace std;
using namespace baboon;
using namespace EVENT;

myProc::myProc()
	: BaboonProcessor("myProc") {

	  _description = "myProc example for core construction";

}

myProc::~myProc() {}


Return myProc::Init() {

	/*
	 * The Init() function is the place to
	 * register algorithms and histograms if needed
	 *
	 */

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );

	// Add core finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );

	// Add clustering (2D and 3D) algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	return BABOON_SUCCESS();
}

Return myProc::ProcessRunHeader( LCRunHeader* run ) {

	return BABOON_SUCCESS();
}

Return myProc::ProcessEvent( EVENT::LCEvent * evt ) {

	// Grab the hitCollection for the current event
	HitCollection *hitCollection = hitManager->GetHitCollection();

	cout << "event no " << evt->getEventNumber() << endl;

	if( hitCollection->empty() )
		return BABOON_NOT_INITIALIZED("No hit in the current event. Framework not initialized!");

	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		IsolationTaggingAlgorithm* isolationAlgo = (IsolationTaggingAlgorithm *) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		isolationAlgo->Process();
	}


	if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

		CoreFinderAlgorithm *coreFinder = (CoreFinderAlgorithm *) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
		coreFinder->Process();
	}


	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		// Give to the algorithm an empty cluster collection
		ClusterCollection *clustCol = new ClusterCollection();

		ClusteringAlgorithm* clusteringAlgo = (ClusteringAlgorithm *) algorithmManager->GetAlgorithm("ClusteringAlgorithm");

		// 3D clusters are built
		clusteringAlgo->SetClusteringMode( fClustering3D );

		// Build clusters by tag
		clusteringAlgo->SetTaggingMode( fClusterTagMode );

		// Th etag is only fCore
		clusteringAlgo->AddHitTagToCluster( fCore );
		clusteringAlgo->SetClusterCollection( clustCol );

		// Set a lower limit on core sizes
		clusteringAlgo->SetClusterSizeLowerLimit( 5 );
		clusteringAlgo->Process();

		// Register cores in the CoreManager
		for( unsigned int i=0 ; i<clustCol->size() ; i++ ) {

			HitCollection *hitCol = clustCol->at(i)->GetHitCollection();
			Core *core = new Core();
			for( unsigned int j=0 ; j<hitCol->size() ; j++ ) {
				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , core->AddHit( hitCol->at(j) ) );
			}
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , coreManager->AddCore( core ) );

		}
		// clear the cluster collection. No need anymore
		clustCol->clear();
		delete clustCol;
	}


	vector<int> coreSizes;
	int nbOfIsolatedHits = 0;
	CoreCollection *coreCollection = coreManager->GetCoreCollection();

	for( unsigned int c=0 ; c<coreCollection->size() ; c++ )
		coreSizes.push_back( coreCollection->at( c )->Size() );

	for( unsigned int h=0 ; h<hitCollection->size() ; h++ ) {

		IntVector ijk = hitCollection->at(h)->GetIJK();

		if( hitCollection->at( h )->GetHitTag() == fIsolated )
			nbOfIsolatedHits++;

		if( hitCollection->at(h)->GetHitTag() == fCore ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kMagenta);
		}

		if( hitCollection->at(h)->GetHitTag() == fIsolated ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kBlue);
		}
	}

	/*
	 *
	 * Write in a root file the current cores
	 * and the isolated hits statistics
	 *
	 */
	analysisManager->Set("myTree","coreSize_branch",&coreSizes);
	analysisManager->Set("myTree","nbOfCores_branch",int(coreCollection->size()) );
	analysisManager->Set("myTree","nbOfIsolatedHits_branch",nbOfIsolatedHits);
	analysisManager->Fill("myTree");

	return BABOON_SUCCESS();
}


Return myProc::Check( LCEvent *evt ) {

	return BABOON_SUCCESS();
}

Return myProc::End() {

	return BABOON_SUCCESS();
}



