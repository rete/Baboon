  /// \file myProc.cc
/*
 *
 * ShowerSplitterProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "myProc.hh"


myProc amyProc;


using namespace std;
using namespace baboon;

myProc::myProc()
	: marlin::Processor("myProc") {

	  _description = "myProc for shower splitting in SDHCAL";

	  // register steering parameters: name, description, class-variable, default value

	  registerProcessorParameter( "BABOON_HOME" ,
				      "Path to Baboon directory install",
				      baboonHome,
				      string("/home/remi/ilcsoft/SDHCAL/Baboon") );

	  string cfgFileName = string("/home/remi/ilcsoft/SDHCAL/Baboon/config/SDHCAL.cfg");
	  registerProcessorParameter("SDHCAL_cfg" ,
				     "SDHCAL configurations" ,
				     configFileName,
				     cfgFileName);

	  string algoFileName = string("/home/remi/ilcsoft/SDHCAL/Baboon/config/Algorithm.cfg");
	  registerProcessorParameter("Algorithm_cfg" ,
				     "Algorithm configurations" ,
				     algorithmFileName,
				     algoFileName);

	  registerProcessorParameter("rootOutputFile" ,
				     "root outputfile" ,
				     rootOutputFile,
				     string("ShowerSplitter.root"));

	  registerProcessorParameter("decoderString" ,
				     "decoder string for cell ID decoder" ,
				     decoderString,
				     string("M:3,S-1:3,I:9,J:9,K-1:6"));

	  registerProcessorParameter("collectionName" ,
				     "collection name for SDHCAL hits" ,
				     collectionName,
				     string("HCALBarrel"));

}

myProc::~myProc() {}


void myProc::init() {

	/***********************************************************
	 * Define all algorithms, add them in the algorithm manager
	 ***********************************************************/
	algorithmManager = AlgorithmManager::GetInstance();

	// Add clustering algorithm
	algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() );

	LoadManagers();
}

void myProc::processRunHeader( LCRunHeader* run ) {

}

void myProc::processEvent( LCEvent * evt ) {

	LoadEvent( evt );

	// just to keep tree compatibility with the old version. Will be removed in the future
	int evtNb = evt->getEventNumber();
	cout << "event " << evtNb <<  endl;



	vector<int> I;
	vector<int> J;
	vector<int> K;
	int nbOfClusters = 0;
	vector<int> clusterSizes;


	HitCollection *hitCollection = hitManager->GetHitCollection();
	ClusterCollection *clustCol = new ClusterCollection();


	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		cout << "ClusteringAlgorithm found" << endl;
		ClusteringAlgorithm* clusteringAlgo = (ClusteringAlgorithm *) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clusteringAlgo->SetClusteringMode( fClustering3D );
		clusteringAlgo->SetTaggingMode( fClusterTagMode );
		clusteringAlgo->SetClusterCollection( clustCol );
		clusteringAlgo->Process();

		for( unsigned int i=0 ; i<clustCol->size() ; i++ ) {
			Return ret = ClusteringManager::GetInstance()->AddCluster( clustCol->at(i) );
			if( !ret.OK )
				cout << ret.message << endl;
		}
	}

	for( unsigned int i=0 ; i<clustCol->size() ; i++ ) {
		clusterSizes.push_back( clustCol->at(i)->GetClusterSize() );
	}
	nbOfClusters = clustCol->size();
	clustCol->clear();

	delete clustCol;



	for(unsigned int j=0 ; j<hitCollection->size() ; j++) {

		IntVec ijk = hitCollection->at(j)->GetIJK();
		I.push_back( ijk.at(0) );
		J.push_back( ijk.at(1) );
		K.push_back( ijk.at(2) );
	}

	analysisManager->Set("myTree","I",&I);
	analysisManager->Set("myTree","J",&J);
	analysisManager->Set("myTree","K",&K);

	analysisManager->Set("myTree","nbOfClusters",nbOfClusters);
	analysisManager->Set("myTree","clusterSizes",&clusterSizes);

	analysisManager->Fill("myTree");

	ClearAllContent();
}


void myProc::check( LCEvent *evt ) {

}

void myProc::end() {

	AnalysisManager::GetInstance()->End();
	AnalysisManager::Kill();
	AlgorithmManager::Kill();
	HitManager::Kill();
	ClusteringManager::Kill();
	CoreManager::Kill();
	ShowerManager::Kill();
	SdhcalConfig::Kill();
}


void myProc::LoadManagers() {

	/************************
	 * SDHCAL configurations
	 ************************/

	SdhcalConfig *config = SdhcalConfig::GetInstance();
	cout << "Loading configuration file : " << configFileName << endl;
	config->LoadFile( configFileName );

	clusteringManager = ClusteringManager::GetInstance();
	analysisManager = AnalysisManager::GetInstance();
	trackManager = TrackManager::GetInstance();
	coreManager = CoreManager::GetInstance();
	hitManager = HitManager::GetInstance();
	showerManager = ShowerManager::GetInstance();

	cout << "ROOT output file : " << rootOutputFile << endl;
	analysisManager->SetRootFileName( rootOutputFile );
	analysisManager->Init();

	algorithmManager->SetConfigFileName( algorithmFileName );
	algorithmManager->Initialize();

}


void myProc::LoadEvent( LCEvent *evt ) {

	caloHitCreator = new baboon::CaloHitCreator();
	caloHitCreator->SetDecoderString( decoderString );
	caloHitCreator->SetCollectionName( collectionName );
	caloHitCreator->CreateCaloHits( evt );

	HitManager *hitManager = HitManager::GetInstance();
	hitManager->BuildVolumeMap();
}


void myProc::ClearAllContent() {

	clusteringManager->ClearAllContent();
	hitManager->ClearAllContent();
	coreManager->ClearAllContent();
	trackManager->ClearAllContent();
	showerManager->ClearAllContent();
	delete caloHitCreator;
}

