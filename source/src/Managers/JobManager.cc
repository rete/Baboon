/*
 *
 * JobManager.cc cpp file template generated by fclass
 * Creation date : Mon Mar 18 00:58:24 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Managers/JobManager.hh"




using namespace std ;




namespace baboon {

	JobManager* JobManager::instance = NULL;


	JobManager::JobManager() {}


	JobManager::~JobManager() {

		ClusteringManager::Kill();
		AlgorithmManager::Kill();
	}


	JobManager* JobManager::GetInstance() {
		if(instance == NULL) instance = new JobManager();
		return instance;
	}


	void JobManager::Kill() {
		if(instance != NULL) {
			delete instance;
			instance = NULL;
		}
	}


	void JobManager::Init() {

		clusteringManager = ClusteringManager::GetInstance();
		algorithmManager = AlgorithmManager::GetInstance();
		analysisManager = AnalysisManager::GetInstance();
	}


	void JobManager::ProcessEvent( EVENT::LCEvent* event) {

		/*
		int evtNb = event->getEventNumber();

		analysisManager->Set("SplitterVariables","event",evtNb);

		EVENT::LCCollection *lcCollection = event->getCollection("HCALBarrel");
		HitManager *hitManager = HitManager::GetInstance();
		hitManager->BeginOfEvent(lcCollection);
		HitCollection *hitCollection = hitManager->GetHitCollection();

		// just to keep tree compatibility with the old version. Will be removed in the future
		analysisManager->Set("SplitterVariables","nbOfClusters",0);
		analysisManager->Set("SplitterVariables", "nbOfTracks" , 0 );

		algorithmManager = AlgorithmManager::GetInstance();

		vector<int> I;
		vector<int> J;
		vector<int> K;

		vector<int> ITrack;
		vector<int> JTrack;
		vector<int> KTrack;

		vector<int> IThrust;
		vector<int> JThrust;
		vector<int> KThrust;

		vector<int> ICore;
		vector<int> JCore;
		vector<int> KCore;

		vector<int> ITrackExtr;
		vector<int> JTrackExtr;
		vector<int> KTrackExtr;

		vector<double> ITrackFitFirst;
		vector<double> JTrackFitFirst;
		vector<double> KTrackFitFirst;

		vector<double> ITrackFitSecond;
		vector<double> JTrackFitSecond;
		vector<double> KTrackFitSecond;

		vector<int> IIsolated;
		vector<int> JIsolated;
		vector<int> KIsolated;

		vector<double> Chi2Vec;
		vector<double> isolationWeights;


//		if( algorithmManager->AlgorithmIsRegistered("NearbyClustering2DAlgorithm") ) {
//
//			cout << "NearbyClustering2DAlgorithm found" << endl;
//			NearbyClustering2DAlgorithm* clustering2D = (NearbyClustering2DAlgorithm *) algorithmManager->GetAlgorithm("NearbyClustering2DAlgorithm");
//			clustering2D->Process();
//		}

		ClusterCollection *clusterCollection = clusteringManager->GetCluster2D();
		cout << "nb of clusters : " << clusterCollection->size() << endl;
		cout << "nb of hits : " << hitCollection->size() << endl;


		if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

			cout << "IsolationTaggingAlgorithm found" << endl;
			IsolationTaggingAlgorithm* isolationAlgo = (IsolationTaggingAlgorithm *) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
			isolationAlgo->SetHitCollection( hitCollection );
			isolationAlgo->Process();
			isolationWeights = isolationAlgo->GetIsolationWeights();

		}

		if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

			cout << "CoreFinderAlgorithm found" << endl;
			CoreFinderAlgorithm *coreFinder = (CoreFinderAlgorithm *) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
			coreFinder->Process();
		}

//		if( algorithmManager->AlgorithmIsRegistered("HoughTransformAlgorithm") ) {
//
//			cout << "HoughTransformAlgorithm found" << endl;
//			HoughTransformAlgorithm *houghTransform = (HoughTransformAlgorithm*) algorithmManager->GetAlgorithm("HoughTransformAlgorithm");
//			houghTransform->Process();
//		}


//		if( algorithmManager->AlgorithmIsRegistered("PrincipalComponentAnalysis") ) {
//
//
//			vector<double> xPos(3,0);
//			vector<double> yPos(3,0);
//			vector<double> zPos(3,0);
//
//			PrincipalComponentAnalysis *pca = (PrincipalComponentAnalysis *) algorithmManager->GetAlgorithm("PrincipalComponentAnalysis");
//			pca->SetHitCollection(hitCollection);
//			cout << "PrincipalComponentAnalysis found" << endl;
//			pca->Process();
//		}



//		if( algorithmManager->AlgorithmIsRegistered("HoughTransformAlgorithm") ) {
//
//			HoughTransformAlgorithm *houghTransform = (HoughTransformAlgorithm*) algorithmManager->GetAlgorithm("HoughTransformAlgorithm");
//			houghTransform->SetClusterCollection( clusterCollection );
//			houghTransform->Process();
//
//			TrackSegmentCollection *trackSegmentCollection = houghTransform->GetTrackSegmentCollection();
//
//			if( algorithmManager->AlgorithmIsRegistered("TrackRefinementAlgorithm") ) {
//
//				TrackRefinementAlgorithm *trackRefinement = (TrackRefinementAlgorithm *)algorithmManager->GetAlgorithm("TrackRefinementAlgorithm");
//				trackRefinement->SetTrackCollection( trackSegmentCollection );
//				trackRefinement->Process();
//
//			}
//
//			analysisManager->Set("SplitterVariables", "nbOfTracks" , int(trackSegmentCollection->size() ) );
//
//
//			for( unsigned int i=0 ; i<trackSegmentCollection->size() ;i ++ ) {
//
//				TrackSegment *trackSegment = trackSegmentCollection->at(i);
//
//				vector<ThreeVector> positions = trackSegment->GetPositions();
//				vector<ThreeVector> weights;
//				weights.assign( positions.size() , ThreeVector(1,1,1) );
//				Linear3DFit fitter(positions,weights);
//				fitter.Fit();
//				ThreeVector firstAnalyticExtr = fitter.VectorFromRealLine( trackSegment->GetExtremities().first->GetPosition() );
//				ThreeVector secondAnalyticExtr = fitter.VectorFromRealLine( trackSegment->GetExtremities().second->GetPosition() );
//				ThreeVector u = firstAnalyticExtr - secondAnalyticExtr;
//				cout << "u : " << u << endl;
//				u.setMag(1);
//				if( u.z() < 0 ) u = -u;
//				DoubleVec IJKdoubleFirst = hitManager->PositionToIJK( firstAnalyticExtr );
//				DoubleVec IJKdoubleSecond = hitManager->PositionToIJK( secondAnalyticExtr );
//
//				ITrackFitFirst.push_back( IJKdoubleFirst.at(0) );
//				JTrackFitFirst.push_back( IJKdoubleFirst.at(1) );
//				KTrackFitFirst.push_back( IJKdoubleFirst.at(2) );
//
//				ITrackFitSecond.push_back( IJKdoubleSecond.at(0) );
//				JTrackFitSecond.push_back( IJKdoubleSecond.at(1) );
//				KTrackFitSecond.push_back( IJKdoubleSecond.at(2) );
//
//				Chi2Vec.push_back( fitter.GetChi2() / trackSegment->GetHitCollection()->size() );
//
////					cout << "theta angle of segment : " << trackSegment->GetThetaAngle() << endl;
//				HitCollection *hitCol = trackSegment->GetHitCollection();
//
//				if( trackSegment->GetExtremities().first->GetIJK().at(2) < 3
//				 || trackSegment->GetExtremities().second->GetIJK().at(2) < 3) {
//
//					for( unsigned int j=0 ; j<hitCol->size() ; j++ ) hitCol->at(j)->SetHitTag( fThrust );
//
//					ThreeVector showerStartingPoint;
//					if( trackSegment->GetExtremities().first->GetIJK().at(2) > trackSegment->GetExtremities().second->GetIJK().at(2) )
//						showerStartingPoint = trackSegment->GetExtremities().first->GetPosition();
//					else showerStartingPoint = trackSegment->GetExtremities().second->GetPosition();
//
//
//					Hit* hitStartingPoint = hitManager->GetClosestHit( showerStartingPoint , hitCollection );
//
//
//
//					Cylinder *cylinder = new Cylinder( showerStartingPoint , showerStartingPoint + 50.0*u , 30 );
//					for( unsigned int i=0 ; i<hitCollection->size() ; i++ ) {
//						if(  cylinder->Contains( hitCollection->at(i)->GetPosition() ) ) ;
//
//					}
//
//				}
//				trackSegment->GetExtremities().first->SetHitTag( fTrackExtremity );
//				trackSegment->GetExtremities().second->SetHitTag( fTrackExtremity );
//
//			}
//
//		}

		Chi2Vec.push_back( 0 );

		for(unsigned int j=0 ; j<hitCollection->size() ; j++) {

			IntVec ijk = hitCollection->at(j)->GetIJK();

			if( hitCollection->at(j)->GetHitTag()  == fTrack ) {
				ITrack.push_back( ijk.at(0) );
				JTrack.push_back( ijk.at(1) );
				KTrack.push_back( ijk.at(2) );
			}
			else if (hitCollection->at(j)->GetHitTag()  == fTrackExtremity) {
				ITrackExtr.push_back( ijk.at(0) );
				JTrackExtr.push_back( ijk.at(1) );
				KTrackExtr.push_back( ijk.at(2) );
			}
			else if( hitCollection->at(j)->GetHitTag() == fCore ) {
				ICore.push_back( ijk.at(0) );
				JCore.push_back( ijk.at(1) );
				KCore.push_back( ijk.at(2) );
			}
			else if( hitCollection->at(j)->GetHitTag() == fIsolated ) {
				IIsolated.push_back( ijk.at(0) );
				JIsolated.push_back( ijk.at(1) );
				KIsolated.push_back( ijk.at(2) );
			}
			else {
				I.push_back( ijk.at(0) );
				J.push_back( ijk.at(1) );
				K.push_back( ijk.at(2) );
			}
		}

		analysisManager->Set("SplitterVariables","Hitx",&I);
		analysisManager->Set("SplitterVariables","Hity",&J);
		analysisManager->Set("SplitterVariables","Hitz",&K);

		analysisManager->Set("SplitterVariables","HitxTrack",&ITrack);
		analysisManager->Set("SplitterVariables","HityTrack",&JTrack);
		analysisManager->Set("SplitterVariables","HitzTrack",&KTrack);

		analysisManager->Set("SplitterVariables","HitxThrust",&IThrust);
		analysisManager->Set("SplitterVariables","HityThrust",&JThrust);
		analysisManager->Set("SplitterVariables","HitzThrust",&KThrust);

		analysisManager->Set("SplitterVariables","HitxCore",&ICore);
		analysisManager->Set("SplitterVariables","HityCore",&JCore);
		analysisManager->Set("SplitterVariables","HitzCore",&KCore);

		analysisManager->Set("SplitterVariables","HitxTrackExtr",&ITrackExtr);
		analysisManager->Set("SplitterVariables","HityTrackExtr",&JTrackExtr);
		analysisManager->Set("SplitterVariables","HitzTrackExtr",&KTrackExtr);

		analysisManager->Set("SplitterVariables","ITrackFitFirst",&ITrackFitFirst);
		analysisManager->Set("SplitterVariables","JTrackFitFirst",&JTrackFitFirst);
		analysisManager->Set("SplitterVariables","KTrackFitFirst",&KTrackFitFirst);

		analysisManager->Set("SplitterVariables","ITrackFitSecond",&ITrackFitSecond);
		analysisManager->Set("SplitterVariables","JTrackFitSecond",&JTrackFitSecond);
		analysisManager->Set("SplitterVariables","KTrackFitSecond",&KTrackFitSecond);

		analysisManager->Set("SplitterVariables","IIsolated",&IIsolated);
		analysisManager->Set("SplitterVariables","JIsolated",&JIsolated);
		analysisManager->Set("SplitterVariables","KIsolated",&KIsolated);

		analysisManager->Set("SplitterVariables","Chi2Vec",&Chi2Vec);
		analysisManager->Set("SplitterVariables","isolationWeights",&isolationWeights);

		// should be the two last lines
		analysisManager->Fill("SplitterVariables");
		hitManager->EndOfEvent();
		//*/
	}


	void JobManager::End() {

	}



}
