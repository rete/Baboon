/*
 *
 * HitManager.cc cpp file template generated by fclass
 * Creation date : Wed Mar 20 18:19:39 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Managers/HitManager.hh"

using namespace std ;

namespace baboon {


	HitManager *HitManager::instance = 0;

	HitManager::HitManager() {

		SdhcalConfig::GetInstance()->GetData("pads").GetValue("nbOfPadsXYZ",&nbOfPadsXYZ);  // vector 3 elts
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("size",&padsSize);  // vector 2 elts
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("interpadSize",&interpadSize);  // vector 2 elts
		SdhcalConfig::GetInstance()->GetData("layers").GetValue("thickness",&layerThickness);  // double

		hitCollection = new HitCollection();
		Hit **hitMapVolumePtrBuffer = new Hit*[ (nbOfPadsXYZ.at(0)+1) * (nbOfPadsXYZ.at(1)+1) * (nbOfPadsXYZ.at(2)+1)];
		hitMapVolumePtr.Initialize(hitMapVolumePtrBuffer,nbOfPadsXYZ.at(0)+1,nbOfPadsXYZ.at(1)+1,nbOfPadsXYZ.at(2)+1);
	}


	HitManager::~HitManager() {
		ClearAllContent();
		hitMapVolumePtr.Clear();
	}


	HitManager *HitManager::GetInstance() {

		if (instance == 0)
			instance = new HitManager();
		return instance;
	}


	void HitManager::Kill() {

		if(instance != NULL) {
			delete instance;
			instance = NULL;
		}
	}

	Return HitManager::RegisterNewHit( const HitParameters &params ) {

		Hit *hit = new Hit(params);
		hitCollection->push_back(hit);
		return BABOON_SUCCESS();
	}


	Return HitManager::DeleteHit( Hit *hit ) {

		if( hit == 0 )
			return BABOON_INVALID_PARAMETER("while deleting a hit : assertion hit  != 0 failed");

		HitCollection::iterator hitIt = std::find( hitCollection->begin() , hitCollection->end() , hit );

		if( hitIt != hitCollection->end() ) {
			if( *hitIt != 0 )
				delete hit;
			hitCollection->erase( hitIt );
			return BABOON_SUCCESS("Hit found and correctly deleted");
		}
		return BABOON_NOT_FOUND("Hit was not registered by the hit manager. Couldn't delete it!");
	}



	Return HitManager::ClearAllContent() {

		hitMapVolumePtr.Clear();

		if( hitCollection != 0 ) {
			for( unsigned int i=0 ; i<hitCollection->size() ; i++ ) {
				if( hitCollection->at(i) != 0 ) {
					delete hitCollection->at(i);
				}

			}
			hitCollection->clear();
		}
		else {
			hitCollection = new HitCollection();
		}
		return BABOON_SUCCESS("Content cleared!");
	}


	Return HitManager::BuildVolumeMap() {

		for(unsigned int i=0 ; i<hitCollection->size() ; i++) {
			IntVector ijk = hitCollection->at(i)->GetIJK();
			hitMapVolumePtr.SetValue( ijk.at(0) , ijk.at(1) , ijk.at(2) , hitCollection->at(i) );
		}
		return BABOON_SUCCESS();
	}


	bool HitManager::PadIsTouched( unsigned int I , unsigned int J , unsigned int K ) {

		if( hitMapVolumePtr.GetValue(I,J,K) == 0 ) return false;
		return true;
	}


	Hit *HitManager::GetHitAt( unsigned int I , unsigned int J , unsigned int K ) {
		return hitMapVolumePtr.GetValue( I , J , K );
	}


	DoubleVector HitManager::PositionToIJK( const ThreeVector& v ) {

		DoubleVector retVec;
		double I = (nbOfPadsXYZ.at(0)/2.0) + v.x()/(padsSize.at(0)+interpadSize.at(0)); retVec.push_back(I);
		double J = (nbOfPadsXYZ.at(1)/2.0) + v.y()/(padsSize.at(1)+interpadSize.at(1)); retVec.push_back(J);
		double K = (nbOfPadsXYZ.at(2)/2.0) + v.z()/layerThickness; retVec.push_back(K);
		return retVec;
	}


	bool HitManager::PadExists( int I , int J , int K ) {

		if( I <= nbOfPadsXYZ.at(0) && I > 0
		 && J <= nbOfPadsXYZ.at(1) && K > 0
		 && K < nbOfPadsXYZ.at(2) && K >= 0 )
			return true;

		return false;
	}


}





