  /// \file Section.cc
/*
 *
 * Section.cc source template generated by fclass
 * Creation date : mar. juin 4 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "CfgParser/Section.hh"

using namespace std;

namespace cfgparser {


	Section::Section() {

	}

	Section::Section( const string n ) {
		name = n;
	}


	Section::Section( Section const &section ) {

		name = section.name;
		keyValueMap = section.keyValueMap;
	}

	Section::~Section() {

	}


	void Section::Append( const string &key , const string &value ) {

		keyValueMap[k] = v;
	}


	bool Section::HasKey( const string &key ) {

//		KeyValueMap::iterator it;
//		for (it=keyValueMap.begin() ; it!=keyValueMap.end() ; it++)
//			if(it->first==k) return true;
//		return false;
		return (keyValueMap.find( key ) != keyValueMap.end() );
	}


	StatusCode Section::GetValue( const string &key , string *value ) {

		if( key.empty() )
			return CFGPARSER_INVALID_SECTION_KEY("Asked key is empty");

		if( keyValueMap.empty() )
			return CFGPARSER_INVALID_SECTION_KEY( string("Section is empty. Couldn't find key ") + key+ string("in section ") + name  );

		string key = k;
		NormalizeName(&key);

		KeyValueMap::iterator it = keyValueMap.find( key );
		if( it == keyValueMap.end() )
			return CFGPARSER_INVALID_SECTION_KEY( string("Couldn't find key ") + key + string("in section ") + name );

		*value = it->second;

		return CFGPARSER_SUCCESS();
	}

	StatusCode Section::GetValue( const string &key , int *value ) {

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		*value = atoi( val.c_str() );
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const string &key , double *value ) {

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		*value = atof( val.c_str() );
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const string &key , vector<string> *value ){

		string val;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( key , &val ) );
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				value->push_back( s );
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( s );
		}
		return CFGPARSER_SUCCESS();
	}


	StatusCode Section::GetValue( const std::string &key , std::vector<double> *value ) {

		string value;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetValue( k , &value) );
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				value->push_back( s );
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( atof( s.c_str() ) );
		}
		return CFGPARSER_SUCCESS();
	}





	StatusCode Section::GetValue( const std::string &key , std::vector<int> *value ) {

		string value;
		GetValue( k , &value);
		string s;
		char motif = ':';

		for (unsigned int i=0 ; i<val.size() ; i++) {

			if( val[i] != motif )
				s.push_back( val[i] ) ;
			else {
				value->push_back( s );
				s = "";
			}
			if( i == val.size() - 1 )
				value->push_back( atoi( s.c_str() ) );
		}
		return CFGPARSER_SUCCESS();
	}


	bool Section::IsEmpty() {
		return keyValueMap.empty();
	}


	StatusCode Section::Print() {

		if( this->IsEmpty() )
			return CFGPARSER_SUCCESS();

		cout << "[" << name << "]" << endl;
		KeyValueMap::iterator it;
		for(it=keyValueMap.begin() ; it!=keyValueMap.end() ; it++)
			cout << "  " << (*it).first << " = " << (*it).second << endl;

		return CFGPARSER_SUCCESS();
	}


	void Section::Clear() {
		keyValueMap.clear();
	}

	Section& Section::operator +=( const Section& section ) {

		KeyValueMap::iterator it;
		for (it = section.keyValueMap.begin() ; it != section.keyValueMap.end() ; it++)
			this->Append( (*it).first , (*it).second );
		return *this;
	}


	Section operator+ ( const Data &data1 , const Data &data2 ) {

		Data data;
		data += data1;
		data += data2;
		data.SetName( data1.GetName() );
		return data;
	}



}  // namespace 

