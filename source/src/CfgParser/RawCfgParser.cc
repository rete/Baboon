  /// \file RawCfgParser.cc
/*
 *
 * RawCfgParser.cc source template generated by fclass
 * Creation date : jeu. juin 6 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "CfgParser/RawCfgParser.hh"

namespace cfgparser {



	RawCfgParser::RawCfgParser() {

		sections.clear();
	}


	RawCfgParser::~RawCfgParser() {


		sections.clear();
	}


	StatusCode RawCfgParser::CreateSection( const std::string &secName ) {

		if( !this->HasSection( secName ) ) {
			Section *section = new Section( secName );
			sections.push_back( section );
			return CFGPARSER_SUCCESS();
		}
		else return CFGPARSER_DUPLICATE_SECTION_ERROR( "Section " + secName + " already exists!" );
	}


	StatusCode RawCfgParser::AddSection( const Section *section ) {

		if( section == 0 )
			return CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion section != 0 failed");

		if( !this->HasSection( section ) ) {
			sections.push_back( section );
			return CFGPARSER_SUCCESS();
		}
		else return CFGPARSER_DUPLICATE_SECTION_ERROR( "Section " + section->GetName() + " already exists!" );
	}


	StatusCode RawCfgParser::GetValue( const std::string& secName , const std::string &key, std::string *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, int *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, double *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, bool *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, std::vector< std::string > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, std::vector< int > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, std::vector< double > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	StatusCode RawCfgParser::GetValue( const std::string& section , const std::string &key, std::vector< bool > *value ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , section->GetValue( key , value );
		return CFGPARSER_SUCCESS();
	}


	bool RawCfgParser::RawCfgParser::HasKey( const std::string &sectionName , const std::string &key ) const {

		Section *section = 0;
		CFGPARSER_THROW_RESULT_IF( CFGPARSER_SUCCESS() , != , this->GetSection( secName , section ) );
		return section->HasKey( key );
	}


	bool RawCfgParser::HasSection( const std::string &secName ) const {

		for( unsigned int i=0 ; i<sections.size() ; i++ ) {
			if( sections.at(i)->GetName() == secName )
				return true;
		}
		return false;
	}


	bool RawCfgParser::HasSection( const Section *section ) const {

		return (std::find( sections.begin() , sections.end() , section ) != sections.end() );
	}


	StatusCode RawCfgParser::GetSection( const std::string &sectionName , Section &sec ) {

		if( sectionName.empty() )
			return CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed");

		for( unsigned int i=0 ; i<section.size() ; i++ ) {
			if( sections.at(i)->GetName() == sectionName ) {
				sec = *sections.at(i);
				return CFGPARSER_SUCCESS();
			}
		}
		return CFGPARSER_NO_SECTION_ERROR( "Section " + sectionName + " not found!" );
	}

	StatusCode RawCfgParser::GetSection( const std::string &sectionName , Section *sec ) {

		if( sectionName.empty() )
			return CFGPARSER_MISSING_SECTION_NAME_ERROR("Assertion !section.empty() failed");

		for( unsigned int i=0 ; i<section.size() ; i++ ) {
			if( sections.at(i)->GetName() == sectionName ) {
				sec = sections.at(i);
				return CFGPARSER_SUCCESS();
			}
		}
		return CFGPARSER_NO_SECTION_ERROR( "Section " + sectionName + " not found!" );
	}

	StatucCode RawCfgParser::GetKeys( const std::string &sectionName , std::vector< std::string > &keys ) {

//		KeyValueMap
		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Read( const std::string &fileName ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Read( const std::vector< std::string > &fileNames ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Read( const std::ifstream& stream ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Read( const std::ifstream* stream ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::RemoveKey( const std::string &sectionName , const std::string &key ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::RemoveSection( const std::string &sectionName ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::GetSections( SectionCollection &sections ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, std::string *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, int *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, double *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, bool *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, std::vector< std::string > *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, std::vector< int > *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, std::vector< double > *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::SetValue( const std::string& section , const std::string &key, std::vector< bool > *value ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Write( const std::string &fileName ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Write( const std::ifstream& stream ) {

		return CFGPARSER_SUCCESS();
	}

	StatusCode RawCfgParser::Write( const std::ifstream* stream ) {

		return CFGPARSER_SUCCESS();
	}

}  // namespace 

