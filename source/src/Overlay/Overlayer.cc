/*
 *
 * Overlayer.cc cpp file template generated by fclass
 * Creation date : Wed Mar 13 14:23:21 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Overlay/Overlayer.hh"



using namespace std ;



namespace baboon {

	Overlayer::Overlayer( CaloHitCollection *col1 , CaloHitCollection *col2) {

		collection1 = col1;
		collection2 = col2;
		collectionTranslation1 = 0;
		collectionTranslation2 = 0;
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("nbOfPadsXYZ",&nbOfPadsXYZ);
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("size",&padsSize);
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("interpadSize",&interpadSize);
		SdhcalConfig::GetInstance()->GetData("layers").GetValue("thickness",&layerThickness);
		overlaidCollection = new CaloHitCollection();
		collectionsTranslated = false;
		lostHitCollection = new CaloHitCollection();
	}

	Overlayer::~Overlayer() {

		delete overlaidCollection;
		delete collectionTranslation1;
		delete collectionTranslation2;
		delete lostHitCollection;
	}

	Return Overlayer::TranslateCollections() {

		if( !collectionsTranslated ) {

			lostHits = 0;

			if( collectionTranslation1 == 0 )
				return BABOON_NOT_INITIALIZED("Assertion collectionTranslation1 != 0 failed");
			if( collectionTranslation2 == 0 )
				return BABOON_NOT_INITIALIZED("Assertion collectionTranslation2 != 0 failed");

			for(int eltID=0 ; eltID<collection1->size() ; eltID++) {

				CaloHit *caloHit = collection1->at( eltID );
				IntVector ijk = caloHit->GetIJK();

				// if the hit is outside of the sdhcal remove it from the collection!
				if( ( ijk.at(0) + round( collectionTranslation1->x()) ) < 0
				||  ( ijk.at(1) + round( collectionTranslation1->y()) ) < 0
				||  ( ijk.at(2) + round( collectionTranslation1->z()) ) < 0
				||  ( ijk.at(0) + round( collectionTranslation1->x()) ) > nbOfPadsXYZ.at(0)
				||  ( ijk.at(1) + round( collectionTranslation1->y()) ) > nbOfPadsXYZ.at(1)
				||  ( ijk.at(2) + round( collectionTranslation1->z()) ) > nbOfPadsXYZ.at(2) ) {

					collection1->erase( collection1->begin() + eltID );
					lostHits++;
					lostHitCollection->push_back( caloHit );
				}
				else {
					caloHit->SetIJK( ijk.at(0) + round( collectionTranslation1->x() )
										,ijk.at(1) + round( collectionTranslation1->y() )
										,ijk.at(2) + round( collectionTranslation1->z() ) );

					ThreeVector pos;
					double xShift = padsSize.at(0) + interpadSize.at(0);
					double yShift = padsSize.at(1) + interpadSize.at(1);
					double zShift = layerThickness;
					pos.setX( caloHit->GetPosition().x() + xShift*round(collectionTranslation1->x()) );
					pos.setY( caloHit->GetPosition().y() + yShift*round(collectionTranslation1->y()) );
					pos.setZ( caloHit->GetPosition().z() + zShift*round(collectionTranslation1->z()) );
					caloHit->SetPosition(pos);
				}
			}

			for(int eltID=0 ; eltID<collection2->size() ; eltID++) {

				CaloHit *caloHit = collection2->at( eltID );
				IntVector ijk = caloHit->GetIJK();

				// if the hit is outside of the sdhcal remove it from the collection!
				if( ( ijk.at(0) + round( collectionTranslation2->x()) ) < 0
				||  ( ijk.at(1) + round( collectionTranslation2->y()) ) < 0
				||  ( ijk.at(2) + round( collectionTranslation2->z()) ) < 0
				||  ( ijk.at(0) + round( collectionTranslation2->x()) ) > nbOfPadsXYZ.at(0)
				||  ( ijk.at(1) + round( collectionTranslation2->y()) ) > nbOfPadsXYZ.at(1)
				||  ( ijk.at(2) + round( collectionTranslation2->z()) ) > nbOfPadsXYZ.at(2) ) {

					collection2->erase( collection2->begin() + eltID );
					lostHits++;
					lostHitCollection->push_back( caloHit );
				}
				else {
					caloHit->SetIJK( ijk.at(0) + round( collectionTranslation2->x() )
								,ijk.at(1) + round( collectionTranslation2->y() )
								,ijk.at(2) + round( collectionTranslation2->z() ) );

					ThreeVector pos;
					double xShift = padsSize.at(0) + interpadSize.at(0);
					double yShift = padsSize.at(1) + interpadSize.at(1);
					double zShift = layerThickness;
					pos.setX( caloHit->GetPosition().x() + xShift*round(collectionTranslation2->x()) );
					pos.setY( caloHit->GetPosition().y() + yShift*round(collectionTranslation2->y()) );
					pos.setZ( caloHit->GetPosition().z() + zShift*round(collectionTranslation2->z()) );
					caloHit->SetPosition(pos);
				}
			}
			collectionsTranslated = true;
			return BABOON_SUCCESS();
		}
		return BABOON_ERROR("Can't translate collections more than one time");
	}


	Return Overlayer::OverlayCollections() {

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->TranslateCollections() );

		for( unsigned int i=0 ; i<collection1->size() ; i++ )
			overlaidCollection->push_back( collection1->at(i) );

		int count = 0;

		for( unsigned int j=0 ; j<collection2->size() ; j++ ) {

			CaloHit *caloHit2 = collection2->at(j);
			IntVector ijk2 = caloHit2->GetIJK();

			bool hitIsOverlaid = false;

			for( int i=0 ; i<collection1->size() ; i++ ) {

				CaloHit *caloHit1 = collection1->at(i);
				IntVector ijk1 = caloHit1->GetIJK();

				if( ijk1.at(0) == ijk2.at(0)
				 && ijk1.at(1) == ijk2.at(1)
				 && ijk1.at(2) == ijk2.at(2) ) {

					hitIsOverlaid = true;
					count ++;
					caloHit1->SetTypeID(3);    // Overlaid hit type
					CaloHitThreshold thresholdTable[3][3] = { fCaloHitThr1 , fCaloHitThr2 , fCaloHitThr3 ,
															  fCaloHitThr2 , fCaloHitThr2 , fCaloHitThr3 ,
															  fCaloHitThr3 , fCaloHitThr3 , fCaloHitThr3 };
					CaloHitThreshold fThr1 = caloHit1->GetThreshold();
					CaloHitThreshold fThr2 = caloHit2->GetThreshold();
					CaloHitThreshold newThr = thresholdTable [ThresholdToInt(fThr1)][ThresholdToInt(fThr2)];

					if( newThr == fThr1 ) continue;
					else {
						caloHit1->SetThreshold( newThr );
					}

				}
				if( hitIsOverlaid ) break;
			}

			if( !hitIsOverlaid ) overlaidCollection->push_back( caloHit2 );
		}
		return BABOON_SUCCESS();
	}



	int Overlayer::ThresholdToInt( CaloHitThreshold fThr ) {

		if( fThr == fCaloHitThr1 ) return 0;
		else if( fThr == fCaloHitThr2 ) return 1;
		else return 2;
	}



}
