/*
 *
 * Overlayer.cc cpp file template generated by fclass
 * Creation date : Wed Mar 13 14:23:21 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Overlay/Overlayer.hh"



using namespace std ;



namespace baboon {

	Overlayer::Overlayer( HitCollection *col1 , HitCollection *col2) {

		collection1 = col1;
		collection2 = col2;
		collectionTranslation1 = 0;
		collectionTranslation2 = 0;
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("nbOfPadsXYZ",&nbOfPadsXYZ);
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("size",&padsSize);
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("interpadSize",&interpadSize);
		SdhcalConfig::GetInstance()->GetData("layers").GetValue("thickness",&layerThickness);
		overlaidCollection = new HitCollection();
		collectionsTranslated = false;
	}

	Overlayer::~Overlayer() {

		delete overlaidCollection;
		delete collectionTranslation1;
		delete collectionTranslation2;
	}

	void Overlayer::TranslateCollections() {

		if( !collectionsTranslated ) {

			lostHits = 0;

			if( collectionTranslation1 == 0 ) return;
			if( collectionTranslation2 == 0 ) return;

			for(int eltID=0 ; eltID<collection1->size() ; eltID++) {

				Hit *hit = collection1->at( eltID );
				IntVector ijk = hit->GetIJK();

				// if the hit is outside of the sdhcal remove it from the collection!
				if( ( ijk.at(0) + round( collectionTranslation1->x()) ) < 0
				||  ( ijk.at(1) + round( collectionTranslation1->y()) ) < 0
				||  ( ijk.at(2) + round( collectionTranslation1->z()) ) < 0
				||  ( ijk.at(0) + round( collectionTranslation1->x()) ) > nbOfPadsXYZ.at(0)
				||  ( ijk.at(1) + round( collectionTranslation1->y()) ) > nbOfPadsXYZ.at(1)
				||  ( ijk.at(2) + round( collectionTranslation1->z()) ) > nbOfPadsXYZ.at(2) ) {

					delete hit;
					collection1->erase( collection1->begin() + eltID );
					lostHits++;
				}
				else {
					hit->SetIJK( ijk.at(0) + round( collectionTranslation1->x() )
										,ijk.at(1) + round( collectionTranslation1->y() )
										,ijk.at(2) + round( collectionTranslation1->z() ) );

					ThreeVector pos;
					double xShift = padsSize.at(0) + interpadSize.at(0);
					double yShift = padsSize.at(1) + interpadSize.at(1);
					double zShift = layerThickness;
					pos.setX( hit->GetPosition().x() + xShift*round(collectionTranslation1->x()) );
					pos.setY( hit->GetPosition().y() + yShift*round(collectionTranslation1->y()) );
					pos.setZ( hit->GetPosition().z() + zShift*round(collectionTranslation1->z()) );
					hit->SetPosition(pos);
				}
			}

			for(int eltID=0 ; eltID<collection2->size() ; eltID++) {

				Hit *hit = collection2->at( eltID );
				IntVector ijk = hit->GetIJK();

				// if the hit is outside of the sdhcal remove it from the collection!
				if( ( ijk.at(0) + round( collectionTranslation2->x()) ) < 0
				||  ( ijk.at(1) + round( collectionTranslation2->y()) ) < 0
				||  ( ijk.at(2) + round( collectionTranslation2->z()) ) < 0
				||  ( ijk.at(0) + round( collectionTranslation2->x()) ) > nbOfPadsXYZ.at(0)
				||  ( ijk.at(1) + round( collectionTranslation2->y()) ) > nbOfPadsXYZ.at(1)
				||  ( ijk.at(2) + round( collectionTranslation2->z()) ) > nbOfPadsXYZ.at(2) ) {

					delete hit;
					collection2->erase( collection2->begin() + eltID );
					lostHits++;
				}
				else {
					hit->SetIJK( ijk.at(0) + round( collectionTranslation2->x() )
								,ijk.at(1) + round( collectionTranslation2->y() )
								,ijk.at(2) + round( collectionTranslation2->z() ) );

					ThreeVector pos;
					double xShift = padsSize.at(0) + interpadSize.at(0);
					double yShift = padsSize.at(1) + interpadSize.at(1);
					double zShift = layerThickness;
					pos.setX( hit->GetPosition().x() + xShift*round(collectionTranslation2->x()) );
					pos.setY( hit->GetPosition().y() + yShift*round(collectionTranslation2->y()) );
					pos.setZ( hit->GetPosition().z() + zShift*round(collectionTranslation2->z()) );
					hit->SetPosition(pos);
				}
			}
			collectionsTranslated = true;
		}
	}


	void Overlayer::OverlayCollections() {

		this->TranslateCollections();

		for( unsigned int i=0 ; i<collection1->size() ; i++ )
			overlaidCollection->push_back( collection1->at(i) );

		int count = 0;

		for( unsigned int j=0 ; j<collection2->size() ; j++ ) {

			Hit *hit2 = collection2->at(j);
			IntVector ijk2 = hit2->GetIJK();

			bool hitIsOverlaid = false;

			for( int i=0 ; i<collection1->size() ; i++ ) {

				Hit *hit1 = collection1->at(i);
				IntVector ijk1 = hit1->GetIJK();

				if( ijk1.at(0) == ijk2.at(0)
				 && ijk1.at(1) == ijk2.at(1)
				 && ijk1.at(2) == ijk2.at(2) ) {

					hitIsOverlaid = true;
					count ++;
					hit1->SetType(3);    // Overlaid hit type
					HitThreshold thresholdTable[3][3] = { fThreshold1 , fThreshold2 , fThreshold3 ,
														  fThreshold2 , fThreshold2 , fThreshold3 ,
														  fThreshold3 , fThreshold3 , fThreshold3 };
					HitThreshold fThr1 = hit1->GetThreshold();
					HitThreshold fThr2 = hit2->GetThreshold();
					cout << "ThresholdToInt(fThr1) : " << ThresholdToInt(fThr1) << endl;
					cout << "ThresholdToInt(fThr2) : " << ThresholdToInt(fThr2) << endl;
					HitThreshold newThr = thresholdTable [ThresholdToInt(fThr1)][ThresholdToInt(fThr2)];

					if( newThr == fThr1 ) continue;
					else {
						hit1->SetThreshold( newThr );
					}

				}
				if( hitIsOverlaid ) break;
			}

			if( !hitIsOverlaid ) overlaidCollection->push_back( hit2 );
		}
	}



	int Overlayer::ThresholdToInt( HitThreshold fThr ) {

		if( fThr == fThreshold1 ) return 0;
		if( fThr == fThreshold2 ) return 1;
		if( fThr == fThreshold3 ) return 2;
	}



}
