/*
 *
 * Overlayer.cc cpp file template generated by fclass
 * Creation date : Wed Mar 13 14:23:21 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Overlay/Overlayer.hh"



using namespace std ;



namespace sdhcal {

	Overlayer::Overlayer(IMPL::LCCollectionVec * lcCol1 , IMPL::LCCollectionVec * lcCol2) {

		lcCollection1 = lcCol1;
		lcCollection2 = lcCol2;
		collectionTranslation1 = NULL;
		collectionTranslation2 = NULL;
		SdhcalConfig::GetInstance()->GetData("general").GetValue("codingPattern",&codingPattern);
		SdhcalConfig::GetInstance()->GetData("pads").GetValue("nbOfPadsXYZ",&nbOfPadsXYZ);

		lcOverlaidCollection = new IMPL::LCCollectionVec(LCIO::CALORIMETERHIT);
		collectionsTranslated = false;
	}

	Overlayer::~Overlayer() {

		delete lcOverlaidCollection;
		delete collectionTranslation1;
		delete collectionTranslation2;
	}

	void Overlayer::TranslateCollections() {

		if(!collectionsTranslated) {

			lostHits = 0;

			if(collectionTranslation1 == NULL) return;
			if(collectionTranslation2 == NULL) return;

			UTIL::CellIDDecoder<IMPL::CalorimeterHitImpl> idDecoderTr(codingPattern);
			UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> idEncoder1 (codingPattern,lcCollection1);
			UTIL::CellIDEncoder<IMPL::CalorimeterHitImpl> idEncoder2 (codingPattern,lcCollection2);

			for(int eltID=0 ; eltID<lcCollection1->getNumberOfElements() ; eltID++) {

				IMPL::CalorimeterHitImpl* hit = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection1->getElementAt( eltID ) );
				int I = idDecoderTr(hit)["I"];
				int J = idDecoderTr(hit)["J"];
				int K = idDecoderTr(hit)["K-1"];

				// if the hit is outside of the sdhcal remove it from the collection!
				if( ( I + round( collectionTranslation1->x()) ) < 0
				||  ( J + round( collectionTranslation1->y()) ) < 0
				||  ( K + round( collectionTranslation1->z()) ) < 0
				||  ( I + round( collectionTranslation1->x()) ) > nbOfPadsXYZ.at(0)
				||  ( J + round( collectionTranslation1->y()) ) > nbOfPadsXYZ.at(1)
				||  ( K + round( collectionTranslation1->z()) ) > nbOfPadsXYZ.at(2) ) {

					lcCollection1->removeElementAt(eltID);
					lostHits++;
				}
				else {
					idEncoder1["I"] = I + round( collectionTranslation1->x() );
					idEncoder1["J"] = J + round( collectionTranslation1->y() );
					idEncoder1["K-1"] = K + round( collectionTranslation1->z() );
					idEncoder1.setCellID( hit );
					float pos[3];
					pos[0] = hit->getPosition()[0] + 10.408*round(collectionTranslation1->x());
					pos[1] = hit->getPosition()[1] + 10.408*round(collectionTranslation1->y());
					pos[2] = hit->getPosition()[2] + 26.131*round(collectionTranslation1->z());
					hit->setPosition(pos);
				}
			}

			for(int eltID=0 ; eltID<lcCollection2->getNumberOfElements() ; eltID++) {

				IMPL::CalorimeterHitImpl* hit = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection2->getElementAt( eltID ) );
				int I = idDecoderTr(hit)["I"];
				int J = idDecoderTr(hit)["J"];
				int K = idDecoderTr(hit)["K-1"];

				if( ( I + round( collectionTranslation2->x()) ) < 0
				||  ( J + round( collectionTranslation2->y()) ) < 0
				||  ( K + round( collectionTranslation2->z()) ) < 0
				||  ( I + round( collectionTranslation2->x()) ) > nbOfPadsXYZ.at(0)
				||  ( J + round( collectionTranslation2->y()) ) > nbOfPadsXYZ.at(1)
				||  ( K + round( collectionTranslation2->z()) ) > nbOfPadsXYZ.at(2) ) {

					lcCollection2->removeElementAt(eltID);
					lostHits++;
				}
				else {
					idEncoder2["I"] = I + round( collectionTranslation2->x() );
					idEncoder2["J"] = J + round( collectionTranslation2->y() );
					idEncoder2["K-1"] = K + round( collectionTranslation2->z() );
					idEncoder2.setCellID( hit );
					float pos[3];
					pos[0] = hit->getPosition()[0] + 10.408*round(collectionTranslation2->x());
					pos[1] = hit->getPosition()[1] + 10.408*round(collectionTranslation2->y());
					pos[2] = hit->getPosition()[2] + 26.131*round(collectionTranslation2->z());
					hit->setPosition(pos);
				}
			}
			collectionsTranslated = true;
		}
	}


	void Overlayer::OverlayCollections() {

		this->TranslateCollections();

		UTIL::CellIDDecoder<IMPL::CalorimeterHitImpl> idDecoder1(codingPattern);
		UTIL::CellIDDecoder<IMPL::CalorimeterHitImpl> idDecoder2(codingPattern);

		for(int i=0 ; i<lcCollection1->getNumberOfElements() ; i++) {
			IMPL::CalorimeterHitImpl* hit = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection1->getElementAt( i ) );
			lcOverlaidCollection->addElement(hit);
		}

		int count = 0;

		for(int j=0 ; j<lcCollection2->getNumberOfElements() ; j++) {

			IMPL::CalorimeterHitImpl* hit2 = NULL;
			hit2 = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection2->getElementAt( j ) );

			int I2 = idDecoder2(hit2)["I"];
			int J2 = idDecoder2(hit2)["J"];
			int K2 = idDecoder2(hit2)["K-1"];

			bool hitIsOverlaid = false;

			for(int i=0 ; i<lcCollection1->getNumberOfElements() ; i++) {

				IMPL::CalorimeterHitImpl* hit1 = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection1->getElementAt( i ) );
				int I1 = idDecoder1(hit1)["I"];
				int J1 = idDecoder1(hit1)["J"];
				int K1 = idDecoder1(hit1)["K-1"];

				if(I1==I2 && J1==J2 && K1==K2) {
					hitIsOverlaid = true;
//					cout << "toto" << endl;
					count ++;
					hit1->setType(3);    // Overlaid hit type
					float thresholdTable[3][3] = { 2.0 , 1.0 , 3.0 ,
									 	 	 	    1.0 , 1.0 , 3.0 ,
									 	 	 	    3.0 , 3.0 , 3.0 };
					float fThr1 = hit1->getEnergy();
					float fThr2 = hit2->getEnergy();
					float newThr = thresholdTable [int(fThr1)][int(fThr2)];

					if(newThr == fThr1) continue;
					else {
						hit1->setEnergy(newThr);
					}

				}
				if(hitIsOverlaid) break;
			}

			if(!hitIsOverlaid) lcOverlaidCollection->addElement( hit2 );
		}

//		cout << "count : " << count << endl;
//		cout << "lcCollection1->getNumberOfElements() : " << lcCollection1->getNumberOfElements() << endl;
//		cout << "lcCollection2->getNumberOfElements() : " << lcCollection2->getNumberOfElements() << endl;
	}





}
