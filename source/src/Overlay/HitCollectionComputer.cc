/*
 *
 * HitCollectionComputer.cc cpp file template generated by fclass
 * Creation date : Tue Mar 12 08:58:44 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Overlay/HitCollectionComputer.hh"

using namespace std ;

namespace baboon {

//	HitCollectionComputer::HitCollectionComputer(IMPL::LCCollectionVec* lcCol) {
//
//		parser->GetValue("general","codingPattern",&codingPattern);
//		parser->GetValue("pads","nbOfPadsXYZ",&nbOfPadsXYZ);
//		lcCollection = lcCol;
//	}
//
//	HitCollectionComputer::~HitCollectionComputer() {	}
//
//
//	ThreeVector HitCollectionComputer::GetCenterOfGravity() {
//
//		ThreeVector weightVec(0,0,0);
//		ThreeVector centOfGrav(0,0,0);
//		ThreeVector sumWeightVec(0,0,0);
//
//		UTIL::CellIDDecoder<IMPL::CalorimeterHitImpl> idDecoder(codingPattern);
//
//		for (int j=0; j<lcCollection->getNumberOfElements(); ++j) {
//			IMPL::CalorimeterHitImpl *hitImpl = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection->getElementAt(j) );
//			Hit *hit = new Hit(hitImpl);
//
//			ThreeVector cell(idDecoder(hit)["I"]
//							   ,idDecoder(hit)["J"]
//							   ,idDecoder(hit)["K-1"]+1);
//
//			IntVec cell = hit->GetIJK();
//
//			float fThr = hit->getEnergy();
//
//			if(fThr>=2.5)      weightVec.set(3,3,3);
//			else if(fThr>=1.5) weightVec.set(1,1,1);
//			else if(fThr>=0.5) weightVec.set(2,2,2);
//			centOfGrav.set( centOfGrav.x() + weightVec.x()*cell.at(0)
//							,centOfGrav.y() + weightVec.y()*cell.at(1)
//							,centOfGrav.z() + weightVec.z()*cell.at(2) );
//
//			sumWeightVec.set(sumWeightVec.x()+weightVec.x()
//							,sumWeightVec.y()+weightVec.y()
//							,sumWeightVec.z()+weightVec.z());
//		}
//
//		centOfGrav.setX( centOfGrav.x()/sumWeightVec.x() );
//		centOfGrav.setY( centOfGrav.y()/sumWeightVec.y() );
//		centOfGrav.setZ( centOfGrav.z()/sumWeightVec.z() );
//
//		centOfGrav.setX( round( centOfGrav.x() ) );
//		centOfGrav.setY( round( centOfGrav.y() ) );
//		centOfGrav.setZ( round( centOfGrav.z() ) );
//
//		return centOfGrav;
//	}
//
//
//
//
//	int HitCollectionComputer::GetFirstXCellHit() {
//
//		UTIL::CellIDDecoder<IMPL::CalorimeterHitImpl> idDecoder(codingPattern);
//		vector<int> xCellVec;
//		for (int j=0; j<lcCollection->getNumberOfElements(); ++j) {
//			IMPL::CalorimeterHitImpl *hit = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection->getElementAt(j) );
//			xCellVec.push_back( idDecoder(hit)["I"] );
//		}
//		return *(std::min_element(xCellVec.begin(), xCellVec.end()));
//	}
//
//
//
//	int HitCollectionComputer::GetLastXCellHit() {
//
//		UTIL::CellIDDecoder<IMPL::CalorimeterHitImpl> idDecoder(codingPattern);
//		vector<int> xCellVec;
//		for (int j=0; j<lcCollection->getNumberOfElements(); ++j) {
//			IMPL::CalorimeterHitImpl *hit = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection->getElementAt(j) );
//			xCellVec.push_back( idDecoder(hit)["I"] );
//		}
//		return *(std::max_element(xCellVec.begin(), xCellVec.end()));
//	}


}
