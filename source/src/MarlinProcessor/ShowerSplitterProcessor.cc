  /// \file ShowerSplitterProcessor.cc
/*
 *
 * ShowerSplitterProcessor.cc source template generated by fclass
 * Creation date : jeu. mai 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "MarlinProcessor/ShowerSplitterProcessor.hh"


ShowerSplitterProcessor aShowerSplitterProcessor;


using namespace std;
using namespace baboon;
using namespace EVENT;

ShowerSplitterProcessor::ShowerSplitterProcessor()
	: BaboonProcessor("ShowerSplitterProcessor") {

	  _description = "ShowerSplitterProcessor for shower splitting in SDHCAL";

}

ShowerSplitterProcessor::~ShowerSplitterProcessor() {}


Return ShowerSplitterProcessor::Init() {

	// Add the Hough Transform Algorithm for track reconstruction within the sdhcal
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new HoughTransformAlgorithm() ) );

	// Add isolation tagging algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new IsolationTaggingAlgorithm() ) );

	// Add clustering (2D) algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ClusteringAlgorithm() ) );

	// Add core finder algorithm
	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new CoreFinderAlgorithm() ) );

	// Add cone beginning algorithm
//	BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , algorithmManager->RegisterAlgorithm( new ConeBeginningAlgorithm() ) );

	return BABOON_SUCCESS();
}

Return ShowerSplitterProcessor::ProcessRunHeader( LCRunHeader* run ) {

	return BABOON_SUCCESS();
}

Return ShowerSplitterProcessor::ProcessEvent( EVENT::LCEvent * evt ) {


	HitCollection *hitCollection = hitManager->GetHitCollection();

	if( hitCollection->empty() )
		return BABOON_NOT_INITIALIZED("No hit in the current event. Framework not initialized!");

	unsigned int evtNb = evt->getEventNumber();
	// just to keep tree compatibility with the old version. Will be removed in the future
	cout << "event " << evtNb <<  endl;
	analysisManager->Set("SplitterVariables","event",int(evtNb));
	analysisManager->Set("SplitterVariables","nbOfClusters",0);
	analysisManager->Set("SplitterVariables", "nbOfTracks" , 0 );

//	vector<int> I;
//	vector<int> J;
//	vector<int> K;
//
//	vector<int> ITrack;
//	vector<int> JTrack;
//	vector<int> KTrack;
//
//	vector<int> IThrust;
//	vector<int> JThrust;
//	vector<int> KThrust;
//
//	vector<int> ICore;
//	vector<int> JCore;
//	vector<int> KCore;
//
//	vector<int> ITrackExtr;
//	vector<int> JTrackExtr;
//	vector<int> KTrackExtr;
//
//	vector<double> ITrackFitFirst;
//	vector<double> JTrackFitFirst;
//	vector<double> KTrackFitFirst;
//
//	vector<double> ITrackFitSecond;
//	vector<double> JTrackFitSecond;
//	vector<double> KTrackFitSecond;
//
//	vector<int> IIsolated;
//	vector<int> JIsolated;
//	vector<int> KIsolated;

	vector<double> Chi2Vec;
	vector<double> isolationWeights;


	if( algorithmManager->AlgorithmIsRegistered("IsolationTaggingAlgorithm") ) {

		cout << "IsolationTaggingAlgorithm found" << endl;
		IsolationTaggingAlgorithm* isolationAlgo = (IsolationTaggingAlgorithm *) algorithmManager->GetAlgorithm("IsolationTaggingAlgorithm");
		isolationAlgo->Process();
		isolationWeights = isolationAlgo->GetIsolationWeights();
	}

	if( algorithmManager->AlgorithmIsRegistered("CoreFinderAlgorithm") ) {

		cout << "CoreFinderAlgorithm found" << endl;
		CoreFinderAlgorithm *coreFinder = (CoreFinderAlgorithm *) algorithmManager->GetAlgorithm("CoreFinderAlgorithm");
		coreFinder->Process();
	}

	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		cout << "ClusteringAlgorithm found" << endl;
		ClusterCollection *clustCol = new ClusterCollection();
		ClusteringAlgorithm* clusteringAlgo = (ClusteringAlgorithm *) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clusteringAlgo->SetClusteringMode( fClustering3D );
		clusteringAlgo->SetTaggingMode( fClusterTagMode );
		clusteringAlgo->AddHitTagToCluster( fCore );
		clusteringAlgo->SetClusterSizeLowerLimit( 10 );
		clusteringAlgo->SetClusterCollection( clustCol );
		clusteringAlgo->Process();

		for( unsigned int i=0 ; i<clustCol->size() ; i++ ) {

			HitCollection *hitCol = clustCol->at(i)->GetHitCollection();
			Core *core = new Core();
			for( unsigned int j=0 ; j<hitCol->size() ; j++ ) {
				core->AddHit( hitCol->at(j) );
			}
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , coreManager->AddCore( core ) );
		}
		clustCol->clear();
		delete clustCol;
	}

	if( algorithmManager->AlgorithmIsRegistered("ConeBeginningAlgorithm") ) {

		cout << "ConeBeginningAlgorithm found" << endl;
		ConeBeginningAlgorithm *coneBeginning = (ConeBeginningAlgorithm *) algorithmManager->GetAlgorithm("ConeBeginningAlgorithm");
		coneBeginning->Process();
	}


	vector<double> xConePos;
	vector<double> yConePos;
	vector<double> zConePos;
	vector<double> coneAngles;
	vector<double> coneRadius;

	ShowerCollection *showerCollection = showerManager->GetShowerCollection();

	if( !showerCollection->empty() ) {
		for( unsigned int i=0 ; i<showerCollection->size() ; i++ ) {

			Cone *cone = 0;
			cone = showerCollection->at(i)->GetStartingCone();
			if( cone == 0 )
				continue;
			ThreeVector conePeakPos = cone->GetPeakPosition();
			xConePos.push_back( conePeakPos.x() );
			yConePos.push_back( conePeakPos.y() );
			zConePos.push_back( conePeakPos.z() );
			coneAngles.push_back( cone->GetTheta() );
			coneRadius.push_back( cone->GetRadius() );
		}
//		analysisManager->Set("SplitterVariables","xConePos",&xConePos);
//		analysisManager->Set("SplitterVariables","yConePos",&yConePos);
//		analysisManager->Set("SplitterVariables","zConePos",&zConePos);
//		analysisManager->Set("SplitterVariables","coneAngles",&coneAngles);
//		analysisManager->Set("SplitterVariables","coneRadius",&coneRadius);
	}

	if( algorithmManager->AlgorithmIsRegistered("ClusteringAlgorithm") ) {

		cout << "ClusteringAlgorithm found" << endl;
		ClusterCollection *clustCol = new ClusterCollection();
		ClusteringAlgorithm* clusteringAlgo = (ClusteringAlgorithm *) algorithmManager->GetAlgorithm("ClusteringAlgorithm");
		clusteringAlgo->SetClusteringMode( fClustering2D );
		clusteringAlgo->SetTaggingMode( fClusterTagMode );
		clusteringAlgo->SetClusterCollection( clustCol );
		clusteringAlgo->Process();

		for( unsigned int i=0 ; i<clustCol->size() ; i++ )
			BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , clusteringManager->AddCluster( clustCol->at(i) ) );

		clustCol->clear();
		delete clustCol;
	}

	if( algorithmManager->AlgorithmIsRegistered("HoughTransformAlgorithm") ) {

		cout << "HoughTransformAlgorithm found" << endl;
		HoughTransformAlgorithm *houghTransform = (HoughTransformAlgorithm*) algorithmManager->GetAlgorithm("HoughTransformAlgorithm");
		houghTransform->Process();
	}

	SimpleEnergyCalculator *calculator = new SimpleEnergyCalculator();
	calculator->SetHitCollection( hitCollection );
	calculator->CalculateEnergy();
	double energy = calculator->GetEnergy();

	cout << "computed energy : " << energy << endl;

	analysisManager->Set("SplitterVariables", "energy" , energy );

	for(unsigned int j=0 ; j<hitCollection->size() ; j++) {

		IntVector ijk = hitCollection->at(j)->GetIJK();


		if( hitCollection->at(j)->GetThreshold() == fThreshold1 ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGreen);
		}

		if( hitCollection->at(j)->GetThreshold() == fThreshold2 ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kBlue);
		}

		if( hitCollection->at(j)->GetThreshold() == fThreshold3 ) {
			if( graphicalEnvironment )
				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kRed);
		}

//		if( hitCollection->at(j)->GetHitTag() == fTrack ) {
////			ITrack.push_back( ijk.at(0) );
////			JTrack.push_back( ijk.at(1) );
////			KTrack.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
////				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kRed);
//		}
//		else if (hitCollection->at(j)->GetHitTag() == fTrackExtremity) {
////			ITrackExtr.push_back( ijk.at(0) );
////			JTrackExtr.push_back( ijk.at(1) );
////			KTrackExtr.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
////				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
//			calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGreen);
//		}
//		else if( hitCollection->at(j)->GetHitTag() == fCore ) {
////			ICore.push_back( ijk.at(0) );
////			JCore.push_back( ijk.at(1) );
////			KCore.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
////				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGray+3);
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kMagenta);
//		}
//		else if( hitCollection->at(j)->GetHitTag() == fIsolated ) {
////			IIsolated.push_back( ijk.at(0) );
////			JIsolated.push_back( ijk.at(1) );
////			KIsolated.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
////				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetVisibility(0);
//			calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kBlue);
//		}
//		else {
////			I.push_back( ijk.at(0) );
////			J.push_back( ijk.at(1) );
////			K.push_back( ijk.at(2) );
//			if( graphicalEnvironment )
//				calorimeter->GetNodeAt(ijk.at(0),ijk.at(1),ijk.at(2))->GetVolume()->SetLineColor(kGray+3);
//		}
	}

//	analysisManager->Set("SplitterVariables","Hitx",&I);
//	analysisManager->Set("SplitterVariables","Hity",&J);
//	analysisManager->Set("SplitterVariables","Hitz",&K);
//
//	analysisManager->Set("SplitterVariables","HitxTrack",&ITrack);
//	analysisManager->Set("SplitterVariables","HityTrack",&JTrack);
//	analysisManager->Set("SplitterVariables","HitzTrack",&KTrack);
//
//	analysisManager->Set("SplitterVariables","HitxThrust",&IThrust);
//	analysisManager->Set("SplitterVariables","HityThrust",&JThrust);
//	analysisManager->Set("SplitterVariables","HitzThrust",&KThrust);
//
//	analysisManager->Set("SplitterVariables","HitxCore",&ICore);
//	analysisManager->Set("SplitterVariables","HityCore",&JCore);
//	analysisManager->Set("SplitterVariables","HitzCore",&KCore);
//
//	analysisManager->Set("SplitterVariables","HitxTrackExtr",&ITrackExtr);
//	analysisManager->Set("SplitterVariables","HityTrackExtr",&JTrackExtr);
//	analysisManager->Set("SplitterVariables","HitzTrackExtr",&KTrackExtr);
//
//	analysisManager->Set("SplitterVariables","ITrackFitFirst",&ITrackFitFirst);
//	analysisManager->Set("SplitterVariables","JTrackFitFirst",&JTrackFitFirst);
//	analysisManager->Set("SplitterVariables","KTrackFitFirst",&KTrackFitFirst);
//
//	analysisManager->Set("SplitterVariables","ITrackFitSecond",&ITrackFitSecond);
//	analysisManager->Set("SplitterVariables","JTrackFitSecond",&JTrackFitSecond);
//	analysisManager->Set("SplitterVariables","KTrackFitSecond",&KTrackFitSecond);
//
//	analysisManager->Set("SplitterVariables","IIsolated",&IIsolated);
//	analysisManager->Set("SplitterVariables","JIsolated",&JIsolated);
//	analysisManager->Set("SplitterVariables","KIsolated",&KIsolated);

	analysisManager->Set("SplitterVariables","Chi2Vec",&Chi2Vec);
	analysisManager->Set("SplitterVariables","isolationWeights",&isolationWeights);

	analysisManager->Fill("SplitterVariables");

	return BABOON_SUCCESS();
}


Return ShowerSplitterProcessor::Check( LCEvent *evt ) {

	return BABOON_SUCCESS();
}

Return ShowerSplitterProcessor::End() {

	return BABOON_SUCCESS();
}



