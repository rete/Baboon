  /// \file BaboonMonitoring.cc
/*
 *
 * BaboonMonitoring.cc source template generated by fclass
 * Creation date : jeu. juil. 11 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Monitoring/BaboonMonitoring.hh"

#include "TCanvas.h"
#include "TFile.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TROOT.h"
#include "TStyle.h"
#include "TTree.h"

#include <TEveManager.h>
#include <TEveEventManager.h>
#include <TEveViewer.h>
#include <TEvePointSet.h>
#include <TEveArrow.h>
#include <TEveRGBAPalette.h>
#include <TGLViewer.h>

#include <TGeoXtru.h>
#include <TEveGeoShapeExtract.h>
#include <TEveGeoShape.h>

#include <TGeometry.h>
#include <TGeoMaterial.h>
#include <TGeoManager.h>
#include <TEveGeoNode.h>

#include "TParticlePDG.h"

#include <TSystem.h>
#include <TGeoXtru.h>
#include <TGeoMatrix.h>
#include <TGeoTube.h>
#include <TEveBoxSet.h>
#include <TGeoCompositeShape.h>
#include <TEveScene.h>

#include <vector>
#include <assert.h>
#include <math.h>
#include <iostream>
#include <cmath>
#include <fcntl.h>
#include <limits>
#include <algorithm>

namespace baboon {


	BaboonMonitoring *BaboonMonitoring::instance = 0;
	bool BaboonMonitoring::openEveEvent = false;
	int  BaboonMonitoring::eventDisplayCounter = 0;
	bool BaboonMonitoring::isTEveInitialized = false;
	std::map<Tag,int> BaboonMonitoring::tagToColorMap;



	BaboonMonitoring::BaboonMonitoring() {

		rootApplication = new TApplication("BaboonMonitoring", 0, 0);
	    rootApplication->SetReturnFromRun(kTRUE);
	}


	BaboonMonitoring::~BaboonMonitoring() {

		tagToColorMap.clear();

		if( isTEveInitialized ) {

			TEveManager::Terminate();
			gSystem->ProcessEvents();
		}
	    rootApplication->Terminate(0);
	}


	BaboonMonitoring *BaboonMonitoring::GetInstance() {

		if( instance == 0 ) {

			instance = new BaboonMonitoring();
	        TColor::CreateColorWheel();

	        // Build the tag to color map
	        tagToColorMap[fUndefined] = kWhite;
	        tagToColorMap[fTrack] = kRed;
	        tagToColorMap[fTrackExtremity] = kGreen;
	        tagToColorMap[fIsolated] = kBlue;
	        tagToColorMap[fCore] = kMagenta;
	        tagToColorMap[fNoise] = kYellow;

	        gStyle->SetPalette(1);
	        gStyle->SetNumberContours(99);
		}
		return instance;
	}


	void BaboonMonitoring::Kill() {

	}

	void BaboonMonitoring::Pause() const {

	#ifdef __unix__
	    std::cout << "Press return to continue ..." << std::endl;
	    int flag = fcntl(1, F_GETFL, 0);

	    int key = 0;
	    while(true)
	    {
	        gSystem->ProcessEvents();
	        fcntl(1, F_SETFL, flag | O_NONBLOCK);
	        key = getchar();

	        if((key == '\n') || (key == '\r'))
	            break;

	        usleep(1000);
	    }

	    fcntl(1, F_SETFL, flag);
	#else
	    std::cout << "BabonnMonitoring::Pause() is only implemented for unix operating systems." << std::endl;
	#endif
	}



	void BaboonMonitoring::InitializeEve(Char_t transparency) {

	    std::stringstream sstr;
	    sstr << "Event Display " << eventDisplayCounter;

	    if ( isTEveInitialized )
	    {
	        TEveEventManager *currentEvent = gEve->GetCurrentEvent();

	        if (currentEvent)
	        {
	            currentEvent->SetElementNameTitle(sstr.str().c_str(),sstr.str().c_str());
	        }

	        if (!openEveEvent)
	        {
	            gEve->AddEvent(new TEveEventManager(sstr.str().c_str(),sstr.str().c_str()));
	            openEveEvent = true;
	            eventDisplayCounter++;
	        }

	        return;
	    }

//	    gSystem->Load("libGeom");
//	    TGeoManager *geoManager = new TGeoManager("DetectorGeometry", "detector geometry");
//
//	    //--- define some materials
//	    TGeoMaterial *vacuumMaterial = new TGeoMaterial("Vacuum", 0, 0, 0); // dummy material
//	    TGeoMaterial *aluminiumMaterial = new TGeoMaterial("Aluminium", 26.98, 13, 2.7); // dummy material
//
//	    //--- define some media
//	    TGeoMedium *vacuum = new TGeoMedium("Vacuum",1, vacuumMaterial);
//	    TGeoMedium *aluminium = new TGeoMedium("Aluminium",2, aluminiumMaterial);
//
//	    //--- make the top container volume
//	    TGeoVolume *mainDetectorVolume = geoManager->MakeBox("Detector", vacuum, 1000., 1000., 100.);

	    gSystem->Load("libGeom");

	    DetectorManager *man = DetectorManager::GetInstance();

	    if( !man->geometryBuilt )
	    	BABOON_THROW_RESULT( BABOON_NOT_INITIALIZED("Detector geometry is not built! Couldn't display event!") );



//	    geoManager->SetTopVolume( man->topVolume );

	    // Here, build the SDHCAL geometry !
//	    this->InitializeSubDetectors(pMainDetectorVolume, pAluminium, transparency);
//	    this->InitializeGaps(pMainDetectorVolume, pVacuum, transparency);

	    //--- close the geometry
//	    geoManager->CloseGeometry();

	    try
	    {
	        std::cout << "BaboonMonitoring::InitializeEve(): ";
	        const char *display(::getenv("DISPLAY"));

	        if (NULL == display)
	        {
	            std::cout << "DISPLAY environment not set" << std::endl;
	        }
	        else
	        {
	            std::cout << "DISPLAY environment set to " << display << std::endl;
	        }

	        TEveManager::Create();
	    }
	    catch (TEveException &tEveException)
	    {
	        std::cout << "BaboonMonitoring::InitializeEve(): Caught TEveException: " << tEveException.what() << std::endl;

	        try
	        {
	            std::cout << "BaboonMonitoring::InitializeEve(): Attempt to release ROOT from batch mode." << std::endl;
	            gROOT->SetBatch(kFALSE);
	            TEveManager::Create();
	        }
	        catch (TEveException &tEveException)
	        {
	            std::cout << "BaboonMonitoring::InitializeEve(): Caught TEveException: " << tEveException.what() << std::endl;
	            throw std::exception();
	        }
	    }
	    catch ( std::exception &e ) {
	    	std::cerr << "BaboonMonitoring::InitializeEve(): Caught std::exception: " << e.what() << std::endl;
	    	throw std::exception();
	    }

	    TGeoNode *geoNode = man->geoManager->GetTopNode();
	    TEveGeoTopNode *eveGeoTopNode = new TEveGeoTopNode( man->geoManager, geoNode);
	    eveGeoTopNode->SetVisLevel(1);
	    eveGeoTopNode->GetNode()->GetVolume()->SetVisibility(kFALSE);

	    gEve->AddGlobalElement(eveGeoTopNode);

	    TGLViewer *viewerGL = gEve->GetDefaultGLViewer();
	    viewerGL->ColorSet().Background().SetColor(kBlack);

	    gEve->Redraw3D(kTRUE);

	    isTEveInitialized = true;
	    openEveEvent = true;
	}

	//------------------------------------------------------------------------------------------------------------------------------------------



//	void BaboonMonitoring::InitializeDetectors(TGeoVolume *pMainDetectorVolume, TGeoMedium *pSubDetectorMedium, Char_t transparency) {
//
//	}

	void BaboonMonitoring::ViewEvent() {

	    InitializeEve();

	    gEve->Redraw3D();
	    this->Pause();

	    TEveEventManager* current = gEve->GetCurrentEvent();
	    if (current)
	        current->SetRnrSelfChildren(kFALSE,kFALSE);

	    openEveEvent = false;
	    std::cout << "View done" << std::endl;
	}

/*
	TEveElement *BaboonMonitoring::VisualizeHitCollection(const HitCollection *hitCollection, TEveElement *parent, const DisplayMode displayMode ) {

		InitializeEve();

		TEveBoxSet *hits = new TEveBoxSet("SDHCAL_Hits");
		hits->Reset(TEveBoxSet::kBT_FreeBox, kTRUE, 64);
		hits->SetOwnIds(kTRUE);
		hits->SetPickable(kTRUE);
		hits->SetMainTransparency(5);

		hits->SetAntiFlick(kTRUE);

		float cellSize = 10.408;
		float activeMediumThickness = 6.73;
		float boxSizeFactor = 70.0/100.0;

		for( unsigned int i=0 ; i<hitCollection->size() ; i++ ) {

			Hit *hit = hitCollection->at(i);
			IntVector ijk = hit->GetIJK();

			hits->AddBox( ijk.at(0) , ijk.at(1) , ijk.at(2) , cellSize*boxSizeFactor , cellSize*boxSizeFactor , activeMediumThickness*boxSizeFactor );
		}


		hits->SetElementName("SDHCAL_hits");
	    hits->SetElementTitle("SDHCAL_hits");


		if( parent ) {
			parent->AddElement( hits );
		}
		else {
			gEve->AddElement( hits );
			gEve->Redraw3D();
		}
		return hits;
	}
*/

	int BaboonMonitoring::GetHitColor( Hit *hit , const HitDisplayMode displayMode ) {

		if( displayMode == kDisplayUniform ) {
			return kWhite;
		}
		else if( displayMode == kDisplayThresholds ) {

			HitThreshold thr = hit->GetThreshold();
			if( thr == fThreshold1 ) {
				return kGreen;
			}
			else if( thr == fThreshold2 ) {
				return kBlue;
			}
			else if( thr == fThreshold3 ) {
				return kRed;
			}
			else return kWhite;
		}
		else if( displayMode == kDisplayTags ) {
			return tagToColorMap[ hit->GetHitTag() ];
		}
		else if( displayMode ==  kDisplayShowers ) {

			ShowerCollection *showers = ShowerManager::GetInstance()->GetShowerCollection();

			if( showers->empty() )
				return kWhite;

			for( unsigned int sh=0 ; sh<showers->size() ; sh++ ) {

				if( showers->at(sh)->Contains( hit ) ) {
					return sh+2;
				}
			}

			// if not found return kWhite
			return kWhite;
		}
		else return kWhite;

	}


}  // namespace 

