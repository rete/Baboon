/*
 *
 * Track.cc cpp file template generated by fclass
 * Creation date : Fri Mar  1 23:58:57 2013
 * Copyright (c) 2012 CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. Et√©
 */


#include "Objects/TrackSegment.hh"



using namespace std ;



namespace sdhcal {

//	TrackSegment::TrackSegment( HitCollection* col)
//	: hitCollection(col) {
//		trackTag = fTrackUndefined;
//	}

	TrackSegment::TrackSegment() {
		trackTag = fTrackUndefined;
		hitCollection = new HitCollection;
	}

	TrackSegment::~TrackSegment() {
		delete hitCollection;
	}

	TrackSegmentExtremities TrackSegment::GetExtremities() {

		TrackSegmentExtremities extrem;

		bool firstIt = true;
		Hit *hitFirst = NULL;
		Hit *hitSecond = NULL;
		for(unsigned int i=0 ; i<hitCollection->size() ; i++) {
			Hit *hit1 = hitCollection->at(i);
			ThreeVector vec1 = hit1->GetPosition();
			for(unsigned int j=0 ; j<hitCollection->size() ; j++) {
				if(i == j) continue;
				Hit *hit2 = hitCollection->at(j);
				ThreeVector vec2 = hit2->GetPosition();
				if(firstIt) {
					hitFirst = hit1;
					hitSecond = hit2;
//					extrem = make_pair( hit1 , hit2 );
					firstIt = false;
					continue;
				}
				// compare the distance between the two hits with the current minimum distance (in extrem)
				if( (hit1->GetPosition() - hit2->GetPosition()).mag()
						> (hitFirst->GetPosition() - hitSecond->GetPosition()).mag() ) {
					hitFirst = hit1;
					hitSecond = hit2;
				}
			}
		}

		extrem = make_pair( hitFirst , hitSecond );

		return extrem;
	}



	double TrackSegment::GetThetaAngle() {

		extremities = this->GetExtremities();
		ThreeVector vec( extremities.first->GetPosition() - extremities.second->GetPosition() );
		return vec.theta();
	}



	double TrackSegment::GetTrackLength() {
		ThreeVector vec( extremities.first->GetPosition() - extremities.second->GetPosition() );
		return vec.mag();
	}


	std::vector<ThreeVector> TrackSegment::GetPositions() const {

		std::vector<ThreeVector> vecCol;
		for( unsigned int i=0 ; i<hitCollection->size() ; i++ ) {
			vecCol.push_back( hitCollection->at(i)->GetPosition() );
		}
		return vecCol;

	}

	void TrackSegment::AddHit( Hit *hit ) {
		hitCollection->push_back(hit);
	}

	void TrackSegment::RemoveHit( Hit *hit ) {

		HitCollection::iterator pos = find( hitCollection->begin() ,hitCollection->end() ,hit );
		if( pos == hitCollection->end() ) return;
		else hitCollection->erase(pos);
	}

}
