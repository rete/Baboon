/*
 *
 * Cluster.cc cpp file template generated by fclass
 * Creation date : Sat Mar  2 02:06:41 2013
 * Copyright (c) 2012 CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Objects/Cluster.hh"
#include "Objects/Hit.hh"



using namespace std ;



namespace sdhcal {

	Cluster::Cluster() {

		SdhcalConfig::GetInstance()->GetData("general").GetValue(string("codingPattern"),&codingPattern);
		associatedClusters = new ClusterCollection();
		associatedClusters->push_back(this);
		hitCollection = new HitCollection();
		hitCollection->clear();

	}


	void Cluster::SetHitCollection( HitCollection *hitCol ) {

		delete hitCollection;
		hitCollection = hitCol;

	}

	Cluster::~Cluster() {}


	void Cluster::ComputePosition() {

		if( hitCollection->empty() ) return;
		ThreeVector pos(0,0,0);
		if(position == pos) {
			for(unsigned int i=0 ; i<hitCollection->size() ; i++) {
				Hit *hit = hitCollection->at(i);
				IntVec hitIJK = hit->GetIJK();

				pos.set( pos.x() + hitIJK.at(0)
				        ,pos.y() + hitIJK.at(1)
				        ,pos.z() + hitIJK.at(2) );
			}
			pos *= double(1.0/hitCollection->size());
			position = pos;
		}
	}

	bool Cluster::IsIsolatedFromClusters(const ClusterCollection* clusters) {

		bool isol=false;
		int neighbour=0;
		int neighbourbis=0;
		int neighbourbisbis=0;
//		cout << "position : " << position << endl;
		ComputePosition();
		for(int clustID=0 ; clustID<clusters->size() ; clustID++) {

			ThreeVector pos(clusters->at(clustID)->GetPosition() );



			if(abs(position.x()-pos.x())>1
			&& abs(position.x()-pos.x())<10
			&& abs(position.y()-pos.y())>1
			&& abs(position.y()-pos.y())<10
			&& position.z()==pos.z())
				{ neighbour++; }

			if(position.z()!=pos.z()
			&& abs(position.z()-pos.z())<3
			&& abs(position.x()-pos.x())<5
			&& abs(position.y()-pos.y())<5)
				{ neighbourbis++; }

			if(position.z()!=pos.z()
			&& abs(position.z()-pos.z())<3
			&& abs(position.x()-pos.x())<5
			&& abs(position.y()-pos.y())<5
			&& clusters->at(clustID)->GetClusterSize()>8 )
				{ neighbourbisbis++; }
		}

		if( neighbour<2
		&& neighbourbis>0
		&& neighbourbis<6
		&& neighbourbisbis<2 ) {
//			this->SetClusterTag(fIsolated);
			isol=true;
			}

		return isol;
	}


	void Cluster::SetClusterTagRecursive(Tag clustTag) {

		for(unsigned int i=0 ; i<hitCollection->size() ; i++) {
			Hit *hit = hitCollection->at(i);
			if(hit->GetHitTag() != clustTag) hit->SetHitTag(clustTag);
		}
		fClusterTag = clustTag;
	}


	void Cluster::AssociateCluster( Cluster* cl ) {

		if( find( associatedClusters->begin(), associatedClusters->end(), cl  ) != associatedClusters->end() )
			return;
		else
			associatedClusters->push_back(cl);

		unsigned int nbOfClusters = cl->GetAssociatedClusters()->size();

		for(unsigned int clID=0 ; clID<nbOfClusters ; clID++ ) {

			Cluster *cluster = cl->GetAssociatedClusters()->at(clID);
			cluster->AssociateCluster(this);
		}
	}


	bool Cluster::IsAssociatedToCluster( Cluster* cl ) {

		ClusterCollection *clusters = cl->GetAssociatedClusters();
		if( find( clusters->begin() , clusters->end() , this ) != clusters->end() )
			return true;
		else return false;
	}


	void Cluster::AddHit( Hit *hit ) {

		if( !this->ContainsHit(hit) ) hitCollection->push_back(hit);
		else return;
	}


//	void Cluster::AddHitRecursive( Hit *hit ) {
//
//		HitCollection *hitCol = hit->GetCluster()->GetHitCollection();
//		if(hitCol->empty()) return;
//		for ( unsigned int i=0 ; i<hitCol->size() ; i++ ) {
//			this->AddHit(hitCol->at(i));
//		}
//	}


	void Cluster::RemoveHit( Hit *hit ) {

		HitCollection::iterator hitIterator;
		if ( hitCollection->empty() ) return;
		hitIterator = find( hitCollection->begin() , hitCollection->end() , hit );
		if( hitIterator != hitCollection->end() ) {
			hitCollection->erase( hitIterator );
			return;
		}

	}


	bool Cluster::ContainsHit( Hit *hit ) {

		return ( find( hitCollection->begin() , hitCollection->end() , hit ) != hitCollection->end() );

	}

	void Cluster::MergeClusters( Cluster *cl ) {

		HitCollection *hitCol = cl->GetHitCollection();
//		for( unsigned int i=0 ; i<hitCol->size() ; i++ ) this->AddHit(hitCol->at(i));
//		for( unsigned int i=0 ; i<hitCollection->size() ; i++ ) cl->AddHit( hitCollection->at(i) );
		if( !hitCol->empty() && !hitCollection->empty() ) {
			hitCol->at(0)->MergeClusters2D( hitCollection->at(0) );
			hitCol->at(0)->MergeClusters3D( hitCollection->at(0) );
		}

	}

}
