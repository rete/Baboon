/*
 *
 * Cluster.cc cpp file template generated by fclass
 * Creation date : Sat Mar  2 02:06:41 2013
 * Copyright (c) 2012 CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Objects/Cluster.hh"

using namespace std ;

namespace baboon {

	Cluster::Cluster() {

		hitCollection = new HitCollection();
	}


	void Cluster::SetHitCollection( HitCollection *hitCol ) {

		if( hitCollection != 0 ) {
			hitCollection->clear();
			delete hitCollection;
		}
		hitCollection = hitCol;

	}

	Cluster::~Cluster() {

		if( hitCollection != 0 ) {
			hitCollection->clear();
			delete hitCollection;
		}
	}


	void Cluster::ComputePosition() {

		if( hitCollection->empty() ) return;
		ThreeVector pos(0,0,0);
		if(position == pos) {
			for(unsigned int i=0 ; i<hitCollection->size() ; i++) {
				Hit *hit = hitCollection->at(i);
				IntVector hitIJK = hit->GetIJK();

				pos.set( pos.x() + hitIJK.at(0)
				        ,pos.y() + hitIJK.at(1)
				        ,pos.z() + hitIJK.at(2) );
			}
			pos *= double(1.0/hitCollection->size());
			position = pos;
		}
	}

	bool Cluster::IsIsolatedFromClusters(const ClusterCollection* clusters) {

		bool isol=false;
		int neighbour=0;
		int neighbourbis=0;
		int neighbourbisbis=0;
//		cout << "position : " << position << endl;
		ComputePosition();
		for(int clustID=0 ; clustID<clusters->size() ; clustID++) {

			ThreeVector pos(clusters->at(clustID)->GetPosition() );

			if(abs(position.x()-pos.x())>1
			&& abs(position.x()-pos.x())<5
			&& abs(position.y()-pos.y())>1
			&& abs(position.y()-pos.y())<5
			&& position.z()==pos.z())
				{ neighbour++; }

			if(position.z()!=pos.z()
			&& abs(position.z()-pos.z())<3
			&& abs(position.x()-pos.x())<5
			&& abs(position.y()-pos.y())<5)
				{ neighbourbis++; }

			if(position.z()!=pos.z()
			&& abs(position.z()-pos.z())<3
			&& abs(position.x()-pos.x())<5
			&& abs(position.y()-pos.y())<5
			&& clusters->at(clustID)->GetClusterSize()>8 )
				{ neighbourbisbis++; }
		}

		if( neighbour<2
		&& neighbourbis>0
		&& neighbourbis<6
		&& neighbourbisbis<2 ) {
//			this->SetClusterTag(fIsolated);
			isol=true;
			}

		return isol;
	}


	void Cluster::SetClusterTagRecursive( const Tag &clustTag ) {

		for(unsigned int i=0 ; i<hitCollection->size() ; i++) {
			Hit *hit = hitCollection->at(i);
			if(hit->GetHitTag() != clustTag)
				hit->SetHitTag(clustTag);
		}
		fClusterTag = clustTag;
	}


//	void Cluster::AssociateCluster( Cluster* cl ) {
//
//		if( find( associatedClusters->begin(), associatedClusters->end(), cl  ) != associatedClusters->end() )
//			return;
//		else
//			associatedClusters->push_back(cl);
//
//		unsigned int nbOfClusters = cl->GetAssociatedClusters()->size();
//
//		for(unsigned int clID=0 ; clID<nbOfClusters ; clID++ ) {
//
//			Cluster *cluster = cl->GetAssociatedClusters()->at(clID);
//			cluster->AssociateCluster(this);
//		}
//	}


//	bool Cluster::IsAssociatedToCluster( Cluster* cl ) {
//
//		ClusterCollection *clusters = cl->GetAssociatedClusters();
//		if( find( clusters->begin() , clusters->end() , this ) != clusters->end() )
//			return true;
//		else return false;
//	}


	Return Cluster::SetType( const ClusterType &type ) {

		fType = type;
		return BABOON_SUCCESS();
	}


	Return Cluster::AddHit( Hit *hit ) {

		if( hit == 0 )
			return BABOON_INVALID_PARAMETER("Assertion hit != 0 failed");

		if( !this->Contains(hit) ) {
			hitCollection->push_back(hit);
			return BABOON_SUCCESS();
		}
		return BABOON_ALREADY_PRESENT("Hit was already present in the cluster") ;
	}


	Return Cluster::RemoveHit( Hit *hit ) {

		if( hit == 0 )
			return BABOON_INVALID_PARAMETER("Assertion hit != 0 failed");

		if ( hitCollection->empty() )
			return BABOON_INVALID_PARAMETER("Cluster was empty");

		HitCollection::iterator hitIterator;

		hitIterator = find( hitCollection->begin() , hitCollection->end() , hit );
		if( hitIterator != hitCollection->end() ) {
			hitCollection->erase( hitIterator );
			return BABOON_SUCCESS();
		}
		return BABOON_NOT_FOUND("Hit was not found in the cluster");
	}


	bool Cluster::Contains( Hit *hit ) {

		return ( find( hitCollection->begin() , hitCollection->end() , hit ) != hitCollection->end() );
	}


}
