  /// \file HitCompositeObject.cc
/*
 *
 * HitCompositeObject.cc source template generated by fclass
 * Creation date : mar. juil. 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Objects/HitCompositeObject.hh"

namespace baboon {


	StringVector TypedObject::possibleTypes;


	HitCompositeObject::HitCompositeObject() {

		caloHitCollection = new CaloHitCollection();
		objectConnectors = new ObjectConnectorCollection();
	}

	HitCompositeObject::~HitCompositeObject() {


		objectConnectors->clear();
		delete objectConnectors;

		if( caloHitCollection != 0 ) {

			caloHitCollection->clear();
			delete caloHitCollection;
			caloHitCollection = 0;
		}
	}


	Return HitCompositeObject::SetCaloHitCollection( CaloHitCollection *caloHitCol ) {

		if( caloHitCollection != 0 ) {
			caloHitCollection->clear();
			delete caloHitCollection;
		}
		caloHitCollection = caloHitCol;
		return BABOON_SUCCESS();
	}


	Return HitCompositeObject::AddCaloHit( CaloHit *caloHit ) {

		BABOON_CHECK_POINTER( caloHit );

		if( caloHitCollection->empty() ) {
			caloHitCollection->push_back( caloHit );
			return BABOON_SUCCESS();
		}

		if( this->Contains( caloHit ) )
			return BABOON_ALREADY_PRESENT("Hit was already in the collection");
		else {
			caloHitCollection->push_back( caloHit );
			return BABOON_SUCCESS();
		}
	}


	Return HitCompositeObject::RemoveCaloHit( CaloHit *caloHit ) {

		if( caloHitCollection->empty() )
			return BABOON_ALREADY_PRESENT("Try to remove a hit from an empty hit collection.");

		CaloHitCollection::iterator it = std::find( caloHitCollection->begin() , caloHitCollection->end() , caloHit );

		if( it != caloHitCollection->end() ) {
			caloHitCollection->erase( it );
			return BABOON_SUCCESS();
		}
		else {
			return BABOON_NOT_FOUND("Hit was not in the collection.");
		}
	}

	bool HitCompositeObject::Contains( CaloHit *caloHit ) {

		return ( find( caloHitCollection->begin() , caloHitCollection->end() , caloHit ) != caloHitCollection->end() );
	}

//---------------------------------------------------------------------------------------------------------------------------

	bool HitCompositeObject::IsConnectedTo( HitCompositeObject *obj ) {

		for( unsigned int c=0 ; c<objectConnectors->size() ; c++ ) {
			if( objectConnectors->at(c)->GetSecond() == obj )
				return true;
		}
		return false;
	}

	Return HitCompositeObject::ConnectWith( HitCompositeObject *obj ) {

		if( obj == 0 )
			return BABOON_INVALID_PARAMETER("Assertion obj != 0 failed");

		if( this->IsConnectedTo( obj ) )
			return BABOON_ALREADY_PRESENT("Object is already connected to the object passed as argument");

		ObjectConnector *newConnector = new ObjectConnector();

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , newConnector->Connect( this , obj ) );

		objectConnectors->push_back( newConnector );

		return BABOON_SUCCESS();
	}


	Return HitCompositeObject::RemoveConnectionWith( HitCompositeObject *obj ) {

		if( obj == 0 )
			return BABOON_INVALID_PARAMETER("Assertion obj != 0 failed");

		for( unsigned int c=0 ; c<objectConnectors->size() ; c++ ) {

			if( objectConnectors->at(c)->GetSecond() == obj ) {

				delete objectConnectors->at(c);
				objectConnectors->erase( objectConnectors->begin() + c );
				return BABOON_SUCCESS();
			}
		}
		return BABOON_NOT_FOUND("Could not remove connection : no connection found!");
	}


}  // namespace 

