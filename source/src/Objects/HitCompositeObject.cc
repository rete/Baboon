  /// \file HitCompositeObject.cc
/*
 *
 * HitCompositeObject.cc source template generated by fclass
 * Creation date : mar. juil. 9 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Objects/HitCompositeObject.hh"

namespace baboon {


	StringVector TypedObject::possibleTypes;


	HitCompositeObject::HitCompositeObject() {

		hitCollection = new HitCollection();
		objectConnectors = new ObjectConnectorCollection();
	}

	HitCompositeObject::~HitCompositeObject() {

		hitCollection->clear();
		objectConnectors->clear();
		delete objectConnectors;
		if( hitCollection != 0 ) {
			delete hitCollection;
			hitCollection = 0;
		}
	}


	Return HitCompositeObject::SetHitCollection( HitCollection *hitCol ) {

		if( hitCollection != 0 ) {
			hitCollection->clear();
			delete hitCollection;
		}
		hitCollection = hitCol;
		return BABOON_SUCCESS();
	}


	Return HitCompositeObject::AddHit( Hit *hit ) {

		if( hit == 0 )
			return BABOON_INVALID_PARAMETER("Assertion hit != 0 failed");

		if( hitCollection->empty() ) {
			hitCollection->push_back( hit );
			return BABOON_SUCCESS();
		}

		if( this->Contains( hit ) )
			return BABOON_ALREADY_PRESENT("Hit was already in the collection");
		else {
			hitCollection->push_back( hit );
			return BABOON_SUCCESS();
		}
	}


	Return HitCompositeObject::RemoveHit( Hit *hit ) {

		if( hitCollection->empty() )
			return BABOON_ALREADY_PRESENT("Try to remove a hit from an empty hit collection.");

		HitCollection::iterator it = std::find( hitCollection->begin() , hitCollection->end() , hit );

		if( it != hitCollection->end() ) {
			hitCollection->erase( it );
			return BABOON_SUCCESS();
		}
		else {
			return BABOON_NOT_FOUND("Hit was not in the collection.");
		}
	}

	bool HitCompositeObject::Contains( Hit *hit ) {

		return ( find( hitCollection->begin() , hitCollection->end() , hit ) != hitCollection->end() );
	}

//---------------------------------------------------------------------------------------------------------------------------

	bool HitCompositeObject::IsConnectedTo( HitCompositeObject *obj ) {

		for( unsigned int c=0 ; c<objectConnectors->size() ; c++ ) {
			if( objectConnectors->at(c)->GetSecond() == obj )
				return true;
		}
		return false;
	}

	Return HitCompositeObject::ConnectWith( HitCompositeObject *obj ) {

		if( obj == 0 )
			return BABOON_INVALID_PARAMETER("Assertion obj != 0 failed");

		if( this->IsConnectedTo( obj ) )
			return BABOON_ALREADY_PRESENT("Object is already connected to the object passed as argument");

		ObjectConnector *newConnector = new ObjectConnector();

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , newConnector->Connect( this , obj ) );

		objectConnectors->push_back( newConnector );

		return BABOON_SUCCESS();
	}


	Return HitCompositeObject::RemoveConnectionWith( HitCompositeObject *obj ) {

		if( obj == 0 )
			return BABOON_INVALID_PARAMETER("Assertion obj != 0 failed");

		for( unsigned int c=0 ; c<objectConnectors->size() ; c++ ) {

			if( objectConnectors->at(c)->GetSecond() == obj ) {

				delete objectConnectors->at(c);
				objectConnectors->erase( objectConnectors->begin() + c );
				return BABOON_SUCCESS();
			}
		}
		return BABOON_NOT_FOUND("Could not remove connection : no connection found!");
	}


}  // namespace 

