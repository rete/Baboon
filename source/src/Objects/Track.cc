  /// \file Track.cc
/*
 *
 * Track.cc source template generated by fclass
 * Creation date : lun. avr. 29 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */



#include "Objects/Track.hh"


using namespace std;


namespace baboon {

	Track::Track()
	: HitCompositeObject(),
	  TypedObject("Track") {

	}

	Track::~Track() {

	}

	TrackExtremities Track::GetExtremities() {

		TrackExtremities extrem;

		bool firstIt = true;
		CaloHit *caloHitFirst = 0;
		CaloHit *caloHitSecond = 0;

		for(unsigned int i=0 ; i<caloHitCollection->size() ; i++) {

			CaloHit *caloHit1 = caloHitCollection->at(i);
			ThreeVector vec1 = caloHit1->GetPosition();

			for(unsigned int j=0 ; j<caloHitCollection->size() ; j++) {

				if( i == j ) continue;
				CaloHit *caloHit2 = caloHitCollection->at(j);
				ThreeVector vec2 = caloHit2->GetPosition();

				if(firstIt) {
					caloHitFirst = caloHit1;
					caloHitSecond = caloHit2;
//					extrem = make_pair( hit1 , hit2 );
					firstIt = false;
					continue;
				}
				// compare the distance between the two hits with the current minimum distance (in extrem)
				if( (caloHit1->GetPosition() - caloHit2->GetPosition()).mag()
						> (caloHitFirst->GetPosition() - caloHitSecond->GetPosition()).mag() ) {

					caloHitFirst = caloHit1;
					caloHitSecond = caloHit2;
				}

			}

		}

		extrem = make_pair( caloHitFirst , caloHitSecond );

		return extrem;
	}


	std::vector<ThreeVector> Track::GetPositions() const {

		std::vector<ThreeVector> vecCol;
		for( unsigned int i=0 ; i<caloHitCollection->size() ; i++ ) {
			vecCol.push_back( caloHitCollection->at(i)->GetPosition() );
		}
		return vecCol;
	}

	std::vector<ThreeVector> Track::GetIJKs() const {

		std::vector<ThreeVector> ijks;
		for( unsigned int i=0 ; i<caloHitCollection->size() ; i++ ) {
			ThreeVector ijk( caloHitCollection->at(i)->GetIJK().at(0) , caloHitCollection->at(i)->GetIJK().at(1) , caloHitCollection->at(i)->GetIJK().at(2) );
			ijks.push_back( ijk );
		}
		return ijks;
	}

	Return Track::SortHits() {

		if( caloHitCollection->size() <= 1 )
			return BABOON_SUCCESS("Sort one element or an empty list is easy...");

		int i = 0;
		int j = 0;
		CaloHit *caloHit = 0;

		for( j=1 ; j<caloHitCollection->size() ; j++ ) {

			i = j-1;
			while( caloHitCollection->at(j)->GetIJK().at(2) < caloHitCollection->at(i)->GetIJK().at(2) ) {
				caloHit = caloHitCollection->at(i);
				caloHitCollection->at(i) = caloHitCollection->at(j);
				caloHitCollection->at(j) = caloHit;
				i=i-1;
				j=j-1;
				if( i<0 ) break;
			}
		}
		return BABOON_SUCCESS();
	}





}  // namespace 

