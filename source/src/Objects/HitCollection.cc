  /// \file HitCollection.cc
/*
 *
 * HitCollection.cc source template generated by fclass
 * Creation date : jeu. mai 23 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Objects/HitCollection.hh"


using namespace std;


namespace baboon {

	HitCollection::HitCollection()
		: std::vector<Hit*>() {

	}

	HitCollection::~HitCollection() {

	}


	ThreeVector HitCollection::GetBarycenter() {

		ThreeVector weightVec(0,0,0);
		ThreeVector centOfGrav(0,0,0);
		ThreeVector sumWeightVec(0,0,0);

		for ( unsigned int j=0 ; j<this->size() ; j++ ) {

			Hit *hit = this->at(j);
			IntVector ijkVec = hit->GetIJK();
			HitThreshold fThr = hit->GetThreshold();

			if( fThr == fThreshold3 )      weightVec.set(3,3,3);
			else if( fThr == fThreshold2 ) weightVec.set(2,2,2);
			else if( fThr == fThreshold1 ) weightVec.set(1,1,1);

			centOfGrav.set( centOfGrav.x() + weightVec.x()*ijkVec.at(0)
							,centOfGrav.y() + weightVec.y()*ijkVec.at(1)
							,centOfGrav.z() + weightVec.z()*ijkVec.at(2) );

			sumWeightVec.set(sumWeightVec.x()+weightVec.x()
							,sumWeightVec.y()+weightVec.y()
							,sumWeightVec.z()+weightVec.z());
		}

		centOfGrav.setX( centOfGrav.x()/sumWeightVec.x() );
		centOfGrav.setY( centOfGrav.y()/sumWeightVec.y() );
		centOfGrav.setZ( centOfGrav.z()/sumWeightVec.z() );

//		centOfGrav.setX( round( centOfGrav.x() ) );
//		centOfGrav.setY( round( centOfGrav.y() ) );
//		centOfGrav.setZ( round( centOfGrav.z() ) );

		return centOfGrav;
	}


	DoubleVector HitCollection::GetRMS() {

		ThreeVector cog = this->GetBarycenter();
		DoubleVector rms(3,0);
		if( this->size() == 0 ) return rms;

		for( unsigned int i=0 ; i<this->size() ; i++ ) {
			IntVector ijk = this->at(i)->GetIJK();
			rms.at(0) += (cog.x()-ijk.at(0))*(cog.x()-ijk.at(0));
			rms.at(1) += (cog.y()-ijk.at(1))*(cog.y()-ijk.at(1));
			rms.at(2) += (cog.z()-ijk.at(2))*(cog.z()-ijk.at(2));
		}
		rms.at(0) = sqrt(rms.at(0)/this->size());
		rms.at(1) = sqrt(rms.at(1)/this->size());
		rms.at(2) = sqrt(rms.at(2)/this->size());
		return rms;
	}


//	DoubleVector HitCollection::GetRMS( const ThreeVector &axis ) {
//
//		DoubleVector rms(3,0);
//		if( this->size() == 0 ) return rms;
//		for( unsigned int i=0 ; i<this->size() ; i++ ) {
//
//			IntVector ijk = this->at(i)->GetIJK();
//
//			rms.at(0) += (cog.x()-ijk.at(0))*(cog.x()-ijk.at(0));
//			rms.at(1) += (cog.y()-ijk.at(1))*(cog.y()-ijk.at(1));
//			rms.at(2) += (cog.z()-ijk.at(2))*(cog.z()-ijk.at(2));
//		}
//
//	}


	int HitCollection::GetFirstLayer() {

		int first = 1000;
		for( unsigned int i=0 ; i<this->size() ; i++ )
			if( this->at(i)->GetIJK().at(2) < first )
				first = this->at(i)->GetIJK().at(2);

		return first;
	}


	int HitCollection::GetLastLayer() {

		int last = -1000;
		for( unsigned int i=0 ; i<this->size() ; i++ )
			if( this->at(i)->GetIJK().at(2) > last )
				last = this->at(i)->GetIJK().at(2);

		return last;
	}






}  // namespace 

