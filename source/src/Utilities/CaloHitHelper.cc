  /// \file CaloHitHelper.cc
/*
 *
 * CaloHitHelper.cc source template generated by fclass
 * Creation date : ven. juil. 26 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Utilities/CaloHitHelper.hh"

using namespace std;

namespace baboon {


	Return CaloHitHelper::ComputeBarycenter( CaloHitCollection *caloHitCollection , ThreeVector &barycenter ) {

		BABOON_CHECK_POINTER( caloHitCollection );

		ThreeVector weightVec(0,0,0);
		ThreeVector sumWeightVec(0,0,0);

		barycenter.set(0,0,0);

		for ( unsigned int j=0 ; j<caloHitCollection->size() ; j++ ) {

			CaloHit *caloHit = caloHitCollection->at(j);
			IntVector ijkVec = caloHit->GetIJK();
			CaloHitThreshold fThr = caloHit->GetThreshold();

			if( fThr == fCaloHitThr3 )      weightVec.set(3,3,3);
			else if( fThr == fCaloHitThr2 ) weightVec.set(2,2,2);
			else if( fThr == fCaloHitThr1 ) weightVec.set(1,1,1);

			barycenter.set( barycenter.x() + weightVec.x()*ijkVec.at(0)
							,barycenter.y() + weightVec.y()*ijkVec.at(1)
							,barycenter.z() + weightVec.z()*ijkVec.at(2) );

			sumWeightVec.set(sumWeightVec.x()+weightVec.x()
							,sumWeightVec.y()+weightVec.y()
							,sumWeightVec.z()+weightVec.z());
		}

		barycenter.setX( barycenter.x()/sumWeightVec.x() );
		barycenter.setY( barycenter.y()/sumWeightVec.y() );
		barycenter.setZ( barycenter.z()/sumWeightVec.z() );


		return BABOON_SUCCESS();

	}


	Return CaloHitHelper::ComputeRMS( CaloHitCollection *caloHitCollection , DoubleVector &rms ) {

		BABOON_CHECK_POINTER( caloHitCollection );

		ThreeVector cog(0,0,0);
		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , CaloHitHelper::ComputeBarycenter( caloHitCollection , cog ) );

		if( caloHitCollection->empty() )
			return BABOON_SUCCESS();

		rms.clear();
		rms = DoubleVector(3,0);

		for( unsigned int i=0 ; i<caloHitCollection->size() ; i++ ) {

			IntVector ijk = caloHitCollection->at(i)->GetIJK();

			rms.at(0) += (cog.x()-ijk.at(0))*(cog.x()-ijk.at(0));
			rms.at(1) += (cog.y()-ijk.at(1))*(cog.y()-ijk.at(1));
			rms.at(2) += (cog.z()-ijk.at(2))*(cog.z()-ijk.at(2));
		}

		rms.at(0) = sqrt(rms.at(0)/caloHitCollection->size());
		rms.at(1) = sqrt(rms.at(1)/caloHitCollection->size());
		rms.at(2) = sqrt(rms.at(2)/caloHitCollection->size());

		return BABOON_SUCCESS();
	}



	Return CaloHitHelper::GetFirstLayer( CaloHitCollection *caloHitCollection , int &firstLayer ) {

		BABOON_CHECK_POINTER( caloHitCollection );

		firstLayer = 10000;
		for( unsigned int i=0 ; i<caloHitCollection->size() ; i++ )
			if( caloHitCollection->at(i)->GetIJK().at(2) < firstLayer )
				firstLayer = caloHitCollection->at(i)->GetIJK().at(2);

		return BABOON_SUCCESS();
	}


	Return CaloHitHelper::GetLastLayer( CaloHitCollection *caloHitCollection , int &lastLayer ) {

		BABOON_CHECK_POINTER( caloHitCollection );

		lastLayer = -10000;
		for( unsigned int i=0 ; i<caloHitCollection->size() ; i++ )
			if( caloHitCollection->at(i)->GetIJK().at(2) > lastLayer )
				lastLayer = caloHitCollection->at(i)->GetIJK().at(2);

		return BABOON_SUCCESS();
	}


	Return CaloHitHelper::CollectionContainsCaloHit( CaloHitCollection *caloHitCollection , CaloHit *caloHit , bool &contains ) {

		BABOON_CHECK_POINTER( caloHitCollection );
		BABOON_CHECK_POINTER( caloHit );

		contains = ( std::find( caloHitCollection->begin() , caloHitCollection->end() , caloHit ) != caloHitCollection->end() );

		return BABOON_SUCCESS();
	}

}  // namespace 

