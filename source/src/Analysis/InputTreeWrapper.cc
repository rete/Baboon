  /// \file InputTree.cc
/*
 *
 * InputTree.cc source template generated by fclass
 * Creation date : dim. avr. 28 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */



#include "Analysis/InputTreeWrapper.hh"


using namespace std;



namespace baboon {


	InputTTreeWrapper::InputTTreeWrapper() {

		tree = 0;
		nbOfEntries = 0;
		branchMap = 0;
		currentEntry = -1;
	}

	InputTTreeWrapper::InputTTreeWrapper( TTree *pTree )
		: tree(pTree) {
		nbOfEntries = tree->GetEntriesFast();
		branchMap = new TBranchMap;
		Init();
		currentEntry = -1;

	}

	void InputTTreeWrapper::SetTree( TTree *t ) {

		tree = t;
		if( branchMap != 0 ) {
			branchMap->clear();
			delete branchMap;
			branchMap = new TBranchMap;
		}
		nbOfEntries = tree->GetEntriesFast();
		Init();
		currentEntry = -1;
	}

	InputTTreeWrapper::~InputTTreeWrapper() {

		branchMap->clear();
		delete branchMap;
	}


	int InputTTreeWrapper::LoadTree( int entry ) {

		int centry = tree->LoadTree(entry);
		if( tree->GetTreeNumber() != currentEntry ) {
			currentEntry = tree->GetTreeNumber();
		}
		return centry;
	}


	int InputTTreeWrapper::GetEntry( int entry ) {

		return tree->GetEntry(entry);
	}


	int InputTTreeWrapper::LoadEntry( int entry ) {

		LoadTree(entry);
		return GetEntry(entry);
	}


	void InputTTreeWrapper::Init() {

		if(tree) {

			TObjArray *branchesList = tree->GetListOfBranches();
			int nbOfBranches = tree->GetNbranches();

			for( unsigned int i=0 ; i<nbOfBranches ; i++ ) {
				TBranch *br = (TBranch *) branchesList->At(i);
				TLeaf *l = (TLeaf *) br->GetListOfLeaves()->At(0);
				string branchName = string( l->GetName() );
				(*branchMap)[ branchName ] = br;
			}
		}
	}



	template <typename T>
	void InputTTreeWrapper::GetValue( const string &branchName , T &val ) {

		bool found = false;
		for( TBranchMap::iterator it=branchMap->begin() ; it!=branchMap->end() ;it++ ) {

			if( branchName == it->first ) {
				TLeaf *l = (TLeaf *)it->second->GetListOfLeaves()->At(0);
				val = *(T *)l->GetValuePointer();
				found = true;
			}
		}
		if( !found )
			throw runtime_error("Asked branch name doesn't exists!");
	}



	// template initialization
	template void InputTTreeWrapper::GetValue( const std::string &branchName , int &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , double &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , float &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , bool &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , vector<int> &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , vector<double> &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , vector<float> &val );
	template void InputTTreeWrapper::GetValue( const std::string &branchName , vector<bool> &val );


}  // namespace 

