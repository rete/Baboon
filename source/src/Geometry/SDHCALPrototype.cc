  /// \file SDHCALPrototype.cc
/*
 *
 * SDHCALPrototype.cc source template generated by fclass
 * Creation date : dim. mai 19 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Geometry/SDHCALPrototype.hh"

using namespace std;

namespace baboon {

	SDHCALPrototype *SDHCALPrototype::instance = 0;
	TGeoManager *SDHCALPrototype::geoManager = 0;

	SDHCALPrototype::SDHCALPrototype() {

		geometryAlreadyBuilt = false;
		zScaleFactor = 1.0;

	}
	SDHCALPrototype::~SDHCALPrototype() {

	}

	SDHCALPrototype *SDHCALPrototype::GetInstance() {

		if( instance == 0 )
			instance = new SDHCALPrototype();
		return instance;
	}

	void SDHCALPrototype::Kill() {

		if( instance != 0 ) {
			delete instance;
			instance = 0;
		}
	}


	Return SDHCALPrototype::BuildGeometry() {

		if( !geometryAlreadyBuilt ) {

			geoManager = new TGeoManager("SDHCALPrototype","SDHCAL prototype geometry");

			// Create the world volume
			TGeoMaterial *vacMat = new TGeoMaterial("Vacuum",0,0,0);
			TGeoMedium *vacMed = new TGeoMedium("Vacuum",1,vacMat);
			TGeoVolume *top = geoManager->MakeBox("world",vacMed,500,500,500);
			geoManager->SetTopVolume(top);
			geoManager->SetTopVisible(0);

			// Grab the basic config of the sdhcal
			config = SdhcalConfig::GetInstance();
			IntVector nbOfPadsXYZ;
			config->GetData("pads").GetValue("nbOfPadsXYZ",&nbOfPadsXYZ);
			config->GetData("layers").GetValue("thickness",&zScaleFactor);
			ostringstream ss;
			zScaleFactor /= 10.0;

			TGeoVolume *borderpx = geoManager->MakeBox("borderpx",vacMed,0.05, nbOfPadsXYZ.at(1)/2.0 ,0.05);
			TGeoVolume *bordernx = geoManager->MakeBox("bordernx",vacMed,0.05, nbOfPadsXYZ.at(1)/2.0 ,0.05);
			TGeoVolume *borderpy = geoManager->MakeBox("borderpy",vacMed, nbOfPadsXYZ.at(0)/2.0 ,0.05,0.05);
			TGeoVolume *borderny = geoManager->MakeBox("borderny",vacMed, nbOfPadsXYZ.at(0)/2.0 ,0.05,0.05);

			for( int k=0 ; k < nbOfPadsXYZ.at(2) ; k++){
				top->AddNodeOverlap(borderpx,k+1,new TGeoTranslation(0,nbOfPadsXYZ.at(1)/2.0,k*zScaleFactor));
				top->AddNodeOverlap(bordernx,k+1,new TGeoTranslation(nbOfPadsXYZ.at(0),nbOfPadsXYZ.at(1)/2.0,k*zScaleFactor));
				top->AddNodeOverlap(borderpy,k+1,new TGeoTranslation(nbOfPadsXYZ.at(0)/2.0,0,k*zScaleFactor));
				top->AddNodeOverlap(borderny,k+1,new TGeoTranslation(nbOfPadsXYZ.at(0)/2.0,nbOfPadsXYZ.at(1),k*zScaleFactor));
			}

			TGeoNode **hitMapVolumePtrBuffer = new TGeoNode* [(nbOfPadsXYZ.at(0)+1)*(nbOfPadsXYZ.at(1)+1)*(nbOfPadsXYZ.at(2)+1)];
			hitMapVolumePtr.Initialize(hitMapVolumePtrBuffer,nbOfPadsXYZ.at(0)+1,nbOfPadsXYZ.at(1)+1,nbOfPadsXYZ.at(2)+1);

			geometryAlreadyBuilt = true;
			return BABOON_SUCCESS();
		}

		return BABOON_ERROR( "Try to build again the geometry" );
	}


	string SDHCALPrototype::IjkToString( unsigned int I , unsigned int J , unsigned int K ) {

		ostringstream ss;
		ss << "pad_" << I << "_" << J <<"_" << K ;
		return ss.str();
	}

	IntVector SDHCALPrototype::StringToIJK( const string &ijkString ) {

		IntVector ijk;
		string s;
		char motif = '_';
		for (unsigned int i=0 ; i<ijkString.size() ; i++)
		{
			if( ijkString[i] != motif ) {
				s.push_back(ijkString[i]);
			}
			else {
				ijk.push_back( atoi( s.c_str() ) );
				s = "";
			}
			if( i == ijkString.size()-1 )
				ijk.push_back( atoi( s.c_str() ) );
		}
		ijk.erase( ijk.begin() );
		return ijk;
	}


	void SDHCALPrototype::LoadHitCollection( HitCollection *hitCol ) {

		TGeoMaterial *vacMat = new TGeoMaterial("Vacuum",0,0,0);
		TGeoMedium *vacMed = new TGeoMedium("Vacuum",1,vacMat);
		TGeoVolume *top = geoManager->GetTopVolume();
		geoManager->SetVisLevel(4);

		for( unsigned int i=0 ; i<hitCol->size() ; i++ ) {

			Hit *hit = hitCol->at(i);
			IntVector ijk = hit->GetIJK();
			string ijkString = IjkToString( ijk.at(0) , ijk.at(1) , ijk.at(2) );
			TGeoVolume *currentPad = geoManager->MakeBox(ijkString.c_str(),vacMed,0.4,0.4,0.4);
			currentPad->SetLineColor( kGray+3 );
			currentPad->SetLineWidth( 3 );
			currentPad->SetTransparency( 0 );
			currentPad->SetVisibility(1);
			top->AddNode( currentPad , 1 , new TGeoTranslation( ijk.at(0) , ijk.at(1) , zScaleFactor*(ijk.at(2)) ) );
			TGeoNode *currentNode = geoManager->FindNode( ijk.at(0) , ijk.at(1) , zScaleFactor*(ijk.at(2)) );
			hitMapVolumePtr.SetValue( ijk.at(0) , ijk.at(1) , ijk.at(2) , currentNode );
			currentNodeList.push_back(currentNode);
		}
	}

	void SDHCALPrototype::ClearCalorimeter() {

		TGeoVolume *top = geoManager->GetTopVolume();

		for( unsigned int i=0 ; i<currentNodeList.size() ; i++ ) {
			top->RemoveNode( currentNodeList.at(i) );
		}
		currentNodeList.clear();
		hitMapVolumePtr.Clear();
	}

	TGeoNode *SDHCALPrototype::GetNodeAt( unsigned int I , unsigned int J , unsigned int K ) {

		return hitMapVolumePtr.GetValue(I,J,K);
	}

}  // namespace 

