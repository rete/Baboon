/*
 *
 * CoreFinderAlgorithm.cc cpp file template generated by fclass
 * Creation date : Mon Apr  8 17:46:03 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Algorithm/Clustering/CoreFinderAlgorithm.hh"


using namespace std ;

namespace baboon {


	CoreFinderAlgorithm::CoreFinderAlgorithm()
		: AbstractAlgorithm("CoreFinderAlgorithm") {
		hitCollection = 0;
		distance = 1;
		needData = true;
	}

	CoreFinderAlgorithm::~CoreFinderAlgorithm() {}


	void CoreFinderAlgorithm::Init() {

		hitCollection = HitManager::GetInstance()->GetHitCollection();
		threshCountVec.clear();
		data.GetValue("coreCountThreshold",&coreCountThreshold);
		data.GetValue("minimumThresholdConcentration",&minimumThresholdConcentration);

	}

	Return CoreFinderAlgorithm::CheckConsistency() {

		if(hitCollection == 0)
			return S_ERROR("CoreFinderAlgorithm bad init. Please check your inputs!");
		return S_OK();

	}

	void CoreFinderAlgorithm::Execute() {

		HitManager *hitManager = HitManager::GetInstance();

//		HitCollection *hitCollectionCore = new HitCollection();
		int nbOfCoreHits = 0;
		for( unsigned int l=0 ; l<hitCollection->size() ; l++ ) {

			Hit *hit = hitCollection->at(l);
			IntVec ijk = hit->GetIJK();
			HitThreshold thresh = hit->GetThreshold();


			int count = 0;

			for(int i=-1 ; i<=1 ; i++ ) {
				for(int j=-1 ; j<=1 ; j++) {
					for(int k=-1 ; k<=1 ; k++) {

						if( !hitManager->PadExists( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) ) continue;
						if( hitManager->PadIsTouched( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) ) {
							Hit* touchedHit = hitManager->GetHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );
							int factor = 1;
							factor *= (1+touchedHit->GetThreshold());
							count += factor;
						}

					}
				}
			}

//			cout << "count : " << count << endl;
//			if( count >= coreCountThreshold ) {
			if(count / 27.0 >= minimumThresholdConcentration ) {
//				hitCollectionCore->push_back(hit);
				hit->SetHitTag( fCore );
				nbOfCoreHits++;
			}
		}

		CoreCollectionBuilder *coreBuilder = CoreCollectionBuilder::GetInstance();
		coreBuilder->SetForceGenerate( true );
		coreBuilder->GetObject();

		cout << "nb of core hits : " << nbOfCoreHits << endl;
		ClusteringManager * clustMan = ClusteringManager::GetInstance();
		ClusterCollection *coreClusters = clustMan->GetCluster3D();
//		cout << "coreClusters->size() (avant): " << coreClusters->size() << endl;
//		for( unsigned int l=0 ; l<coreClusters->size() ; l++ ) {
//			if( coreClusters->at(l)->GetHitCollection()->size() < 10 ) {
//				coreClusters->at(l)->SetClusterTagRecursive(fUndefined);
//				coreClusters->erase( coreClusters->begin()+l );
//			}
//		}

//		cout << "coreClusters->size() (apres): " << coreClusters->size() << endl;
	}

	void CoreFinderAlgorithm::End() {

	}

}
