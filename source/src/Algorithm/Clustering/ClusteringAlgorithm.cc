  /// \file ClusteringAlgorithm.cc
/*
 *
 * ClusteringAlgorithm.cc source template generated by fclass
 * Creation date : mar. mai 7 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Algorithm/Clustering/ClusteringAlgorithm.hh"

using namespace std;


namespace baboon {



	ClusteringAlgorithm::ClusteringAlgorithm()
		: AbstractAlgorithm("ClusteringAlgorithm") {
		needData = false;
		fMode = fClustering2D;
		hitTagToCluster = fUndefined;
	}

	ClusteringAlgorithm::~ClusteringAlgorithm() {

	}


	void ClusteringAlgorithm::Init() {

	 }


	void ClusteringAlgorithm::Execute() {

		HitManager *hitManager = HitManager::GetInstance();
		HitCollection *hitCollection = hitManager->GetHitCollection();

		HitCollection tempCollection;

		for( unsigned int hitID=0 ; hitID<hitCollection->size() ; hitID++ ) {


			if( find( tempCollection.begin() , tempCollection.end() , hitCollection->at(hitID) ) != tempCollection.end() )
				continue;

			if( hitTagToCluster != fUndefined && hitTagToCluster != hitCollection->at(hitID)->GetHitTag() )
				continue;

			cout << "hit tag : " << TagToString( hitCollection->at(hitID)->GetHitTag() ) << endl;

			tempCollection.push_back( hitCollection->at(hitID) );
			HitCollection *hitCol = new HitCollection();
			hitCol->push_back( hitCollection->at(hitID) );
			IntVector ijk = hitCollection->at(hitID)->GetIJK();

			for( int i=-1 ; i<=1 ; i++ ) {
				for( int j=-1 ; j<=1 ; j++ ) {
					for( int k=-1 ; k<=1 ; k++ ) {

						if( !hitManager->PadExists( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) ) continue;
						if( !hitManager->PadIsTouched( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) ) continue;

						Hit *hit2 = hitManager->GetHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );

						if( hitTagToCluster != fUndefined && hitTagToCluster != hit2->GetHitTag() )
							continue;

						if( find( tempCollection.begin() , tempCollection.end() , hit2 ) != tempCollection.end() )
							continue;

						for( unsigned int hitID2=0 ; hitID2<hitCol->size() ; hitID2++ ) {

							if( abs( hitCol->at(hitID2)->GetIJK().at(0) - hit2->GetIJK().at(0) ) < 2
							 && abs( hitCol->at(hitID2)->GetIJK().at(1) - hit2->GetIJK().at(1) ) < 2
							 && abs( hitCol->at(hitID2)->GetIJK().at(2) - hit2->GetIJK().at(2) ) < 2 )  {

								hitCollection->push_back( hit2 );
								tempCollection.push_back( hit2 );
								break;

							}
						}

					} // end k
				} // end j
			} // end i

			Cluster *cluster = new Cluster();
			cluster->SetHitCollection( hitCol );
			clusterCollection->push_back( cluster );
		}
		tempCollection.clear();

	}


	void ClusteringAlgorithm::End() {

	}


	Return ClusteringAlgorithm::CheckConsistency() {

		if( clusterCollection == 0 || clusterCollection == NULL )
			return S_ERROR("While checking consistency : Cluster collection not set or set to 0 in ClusteringAlgorithm. ");
		if( !clusterCollection->empty() ) {
			for( unsigned int i=0 ; i<clusterCollection->size() ; i++ ) delete clusterCollection->at(i);
			clusterCollection->clear();
			return S_OK("Warning : ClusterCollection has been cleared while checking consistency");
		}
		return S_OK();
	}



}  // namespace 

