  /// \file NearbyClustering3DAlgorithm.cc
/*
 *
 * NearbyClusteringAlgorithm.cc source template generated by fclass
 * Creation date : jeu. avr. 18 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Algorithm/Clustering/NearbyClustering3DAlgorithm.hh"

using namespace std;

namespace sdhcal {

	NearbyClustering3DAlgorithm::NearbyClustering3DAlgorithm()
		: AbstractAlgorithm("NearbyClustering3DAlgorithm") {
		hitCollection = 0;
		distance = 1;
		needData = false;
	}

	NearbyClustering3DAlgorithm::~NearbyClustering3DAlgorithm() {

	}



	void NearbyClustering3DAlgorithm::Init() {

		data.GetValue("distance",&distance);
		hitCollection = HitManager::GetInstance()->GetHitCollection();

	}


	Return NearbyClustering3DAlgorithm::CheckConsistency() {

		if( hitCollection == 0 )
			return S_ERROR("NearbyClustering3DAlgorithm bad init. Please check your inputs!");
		return S_OK();
	}


	void NearbyClustering3DAlgorithm::Execute() {

		HitManager *hitManager = HitManager::GetInstance();

		HitCollection tempStorageCollection;

		for( unsigned int hitID=0 ; hitID<hitCollection->size() ; hitID++ ) {

			if( std::find( tempStorageCollection.begin() , tempStorageCollection.end() , hitCollection->at(hitID) ) != tempStorageCollection.end() )
				continue;

			tempStorageCollection.push_back( hitCollection->at(hitID) );

			IntVec ijk1 = hitCollection->at(hitID)->GetIJK();

			for( int i=-1 ; i<=1 ; i++ ) {
				for( int j=-1 ; j<=1 ; j++ ) {
					for( int k=-1 ; k<=1 ; k++ ) {

						if( !hitManager->PadExists( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k ) ) continue;
						if( !hitManager->PadIsTouched( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k ) ) continue;

						Hit *hit2 = hitManager->GetHitAt( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k );

						hitCollection->at(hitID)->MergeClusters3D( hit2 );
						tempStorageCollection.push_back( hit2 );

					}
				}
			}
		}


//		for( unsigned int hitID=0 ; hitID<hitCollection->size() ; hitID++ ) {
//
//			cout << "cluster size : " << hitCollection->at(hitID)->GetCluster()->GetClusterSize()  << endl;
//
//		}

	}


	void NearbyClustering3DAlgorithm::End() {

	}






}  // namespace 

