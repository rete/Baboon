  /// \file EventPreparation.cc
/*
 *
 * EventPreparation.cc source template generated by fclass
 * Creation date : dim. oct. 20 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : R�mi Et�
 * @version
 * @copyright
 *
 *
 */


#include "Algorithm/EventPreparation.hh"

using namespace std;

namespace baboon {


	EventPreparation::EventPreparation()
		: AbstractAlgorithm("EventPreparation") {

		needData = false;
		shouldCalculateDensities = true;
	}

	EventPreparation::~EventPreparation() {

	}


	Return EventPreparation::Init() {

		try{
			data.GetValue( "shouldCalculateDensities" , &shouldCalculateDensities );
		}
		catch( std::exception &e ) {

			shouldCalculateDensities = true;
		}

		try {
			data.GetValue( "densityX" , &densityX );
			data.GetValue( "densityY" , &densityY );
			data.GetValue( "densityZ" , &densityZ );
		}
		catch( std::exception &e ) {

			densityX = 1;
			densityY = 1;
			densityZ = 1;
		}

		return BABOON_SUCCESS();
	}


	Return EventPreparation::CheckConsistency() {

		return BABOON_SUCCESS();
	}


	Return EventPreparation::Execute() {

		DetectorManager *detectorMan = DetectorManager::GetInstance();
		StringVector detectorList = detectorMan->GetDetectorList();

		for( unsigned int d=0 ; d<detectorList.size() ; d++ ) {

			Detector *detector = detectorMan->GetDetector( detectorList.at(d) );
			Calorimeter *calorimeter = 0;

			if( detector->GetDetectorType() == kCalorimeter ) {

				calorimeter = dynamic_cast< Calorimeter * > ( detector );

				if( shouldCalculateDensities )
					this->CalculateCaloHitDensities( calorimeter );
			}
		}

		return BABOON_SUCCESS();
	}


	Return EventPreparation::End() {

		return BABOON_SUCCESS();
	}


	Return EventPreparation::CalculateCaloHitDensities( Calorimeter *calorimeter ) {

		BABOON_CHECK_POINTER( calorimeter );

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();
		unsigned int size = caloHitCollection->size();

		map< CaloHitThreshold , double > thresholdToFactorMap;
		thresholdToFactorMap[ fCaloHitThr1 ] = 1.0;
		thresholdToFactorMap[ fCaloHitThr2 ] = 1.0;
		thresholdToFactorMap[ fCaloHitThr3 ] = 1.0;

		#pragma omp for parallel default(none) shared(caloHitCollection,calorimeter) private(size,densityX,densityY,densityZ)
		for( unsigned int h=0 ; h<size ; h++ ) {

			CaloHit *currentCaloHit = caloHitCollection->at( h );
			IntVector ijk = currentCaloHit->GetIJK();
			double total = 0.0;
			double count = 0.0;
//			double thr3Factor = thresholdToFactorMap[ fCaloHitThr3 ];
//			total = thr3Factor * (2*densityX+1) * (2*densityY+1) * (2*densityZ+1);


			for( int i=-densityX ; i<=densityX ; i++ ) {
				for( int j=-densityY ; j<=densityY ; j++ ) {
					for( int k=-densityZ ; k<=densityZ ; k++ ) {

						if( k != 0 )
							total += thresholdToFactorMap[ fCaloHitThr3 ]*2;
						else
							total += thresholdToFactorMap[ fCaloHitThr3 ];

						if( !calorimeter->IsPadFired( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) )
							continue;

						CaloHit *otherCaloHit = calorimeter->GetCaloHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );

						double factor = 0.0;

						if( otherCaloHit->GetType() == fSemiDigitalCaloHit )
							factor = thresholdToFactorMap[ otherCaloHit->GetThreshold() ];
						else if( otherCaloHit->GetType() == fAnalogicCaloHit )
							factor = otherCaloHit->GetEnergy();
						else if( otherCaloHit->GetType() == fDigitalCaloHit )
							factor = 1.0;

//						if( k != 0 )
//							factor *= 2.0;

						count += factor;
					}
				}
			}

			currentCaloHit->SetDensity( count/total );
		}

		return BABOON_SUCCESS();
	}

}  // namespace 

