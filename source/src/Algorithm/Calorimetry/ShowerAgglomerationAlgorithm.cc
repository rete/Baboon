  /// \file ShowerAgglomerationAlgorithm.cc
/*
 *
 * ShowerAgglomerationAlgorithm.cc source template generated by fclass
 * Creation date : lun. juil. 8 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Algorithm/Calorimetry/ShowerAgglomerationAlgorithm.hh"

using namespace std;

namespace baboon {


	void ShowerAgglomerationAlgorithm::ConnectedHit::AddConnector( Connector *connector ) {

		if( connector == 0 )
			return;

		if( !this->IsConnectedTo( connector ) ) {
			connectors.push_back( connector );
		}
		return;

	}


	void ShowerAgglomerationAlgorithm::ConnectedHit::RemoveConnector( ShowerAgglomerationAlgorithm::Connector *connector ) {

		if( connector == 0 )
			return;

		std::vector<ShowerAgglomerationAlgorithm::Connector*>::iterator it = std::find( connectors.begin() , connectors.end() , connector );
		if( it != connectors.end() ) {
			connectors.erase( it );
		}
		return;

	}


	bool ShowerAgglomerationAlgorithm::ConnectedHit::IsConnectedTo( ShowerAgglomerationAlgorithm::Connector *connector ) {

		return ( std::find( connectors.begin() , connectors.end() , connector ) != connectors.end() );
	}


	bool ShowerAgglomerationAlgorithm::ConnectedHit::IsConnectedWith( ShowerAgglomerationAlgorithm::ConnectedHit *connectedHit ) {

		for( unsigned int c=0 ; c<connectors.size() ; c++ ) {
			if( connectors.at( c )->GetSecond() == connectedHit )
				return true;
		}
		return false;
	}


	void ShowerAgglomerationAlgorithm::ConnectedHit::SetCaloHit( CaloHit *h ) {

		caloHit = h;
	}


	CaloHit *ShowerAgglomerationAlgorithm::ConnectedHit::GetCaloHit() {

		return caloHit;
	}

	bool ShowerAgglomerationAlgorithm::ConnectedHit::HasNoConnection() {

		return connectors.empty();
	}

// -------------------------------------------------------------------------------------------------------

	void ShowerAgglomerationAlgorithm::Connector::Connect( ShowerAgglomerationAlgorithm::ConnectedHit *point1 , ShowerAgglomerationAlgorithm::ConnectedHit *point2 ) {

		if( point1 == 0 || point2 == 0 )
			return;

		hitPair.first = point1;
		hitPair.second = point2;
		weight = 0;
	}


	void ShowerAgglomerationAlgorithm::Connector::Connect( ShowerAgglomerationAlgorithm::ConnectedHit *point1 , ShowerAgglomerationAlgorithm::ConnectedHit *point2 , double w ) {

		if( point1 == 0 || point2 == 0 )
			return;

		hitPair.first = point1;
		hitPair.second = point2;
		weight = w;
	}


	void ShowerAgglomerationAlgorithm::Connector::Disconnect() {

		hitPair.first = 0;
		hitPair.second = 0;
		weight = 0;
	}

//---------------------------------------------------------------------------------------------

	ShowerAgglomerationAlgorithm::ShowerAgglomerationAlgorithm()
	: AbstractAlgorithm("ShowerAgglomerationAlgorithm") {

		needData = true;
		connectedHitCollection = new ConnectedHitCollection();
		connectorCollection = new ConnectorCollection();
	}

	ShowerAgglomerationAlgorithm::~ShowerAgglomerationAlgorithm() {

		for( unsigned int c=0 ; c<connectedHitCollection->size() ; c++ )
			if( connectedHitCollection->at( c ) != 0 )
				delete connectedHitCollection->at( c );

		connectedHitCollection->clear();
		delete connectedHitCollection;

		for( unsigned int c=0 ; c<connectorCollection->size() ; c++ )
			if( connectorCollection->at( c ) != 0 )
				delete connectorCollection->at( c );

		connectorCollection->clear();
		delete connectorCollection;
	}


	Return ShowerAgglomerationAlgorithm::Init() {

		DoubleVector distance;
		data.GetValue("distanceLimitForConnection",&distance);
		distanceLimitForConnection.setX( distance.at(0) );
		distanceLimitForConnection.setY( distance.at(1) );
		distanceLimitForConnection.setZ( distance.at(2) );

//		data.GetValue("distanceLimitForConnection",&distanceLimitForConnection);

		for( unsigned int c=0 ; c<connectedHitCollection->size() ; c++ )
			if( connectedHitCollection->at( c ) != 0 )
				delete connectedHitCollection->at( c );

		connectedHitCollection->clear();

		for( unsigned int c=0 ; c<connectorCollection->size() ; c++ )
			if( connectorCollection->at( c ) != 0 )
				delete connectorCollection->at( c );

		connectorCollection->clear();

		return BABOON_SUCCESS();
	}


	Return ShowerAgglomerationAlgorithm::CheckConsistency() {

		return BABOON_SUCCESS();
	}


	Return ShowerAgglomerationAlgorithm::Execute() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		if( caloHitCollection->empty() )
			return BABOON_SUCCESS();

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->CreateAllConnectors() );

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->CleanConnectors() );

		BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , this->DrawConnectors() );

		cout << "caloHitCollection->size() : " << caloHitCollection->size() << endl;
		cout << "connectedHitCollection->size() : " << connectedHitCollection->size() << endl;

		return BABOON_SUCCESS();
	}



	Return ShowerAgglomerationAlgorithm::CreateAllConnectors() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		for( unsigned int h1=0 ; h1<caloHitCollection->size() ; h1++ ) {

			CaloHit *caloHit1 = caloHitCollection->at( h1 );
			ConnectedHit *connectedHit1 = new ConnectedHit();
			connectedHit1->SetCaloHit( caloHit1 );

			if( caloHit1->GetTag() == IsolatedTag() || caloHit1->GetTag() == TrackTag() )
				continue;

			for( unsigned int h2=0 ; h2<caloHitCollection->size() ; h2++ ) {

				if( h1 == h2 )
					continue;

				CaloHit *caloHit2 = caloHitCollection->at( h2 );

				if( caloHit1->GetIJK().at(2) >= caloHit2->GetIJK().at(2) )
					continue;

				if( caloHit2->GetTag() == IsolatedTag() || caloHit2->GetTag() == TrackTag() )
					continue;

				ThreeVector distance = caloHit2->GetPosition() - caloHit1->GetPosition();

				if( abs( distance.x() ) > distanceLimitForConnection.x()
				 || abs( distance.y() ) > distanceLimitForConnection.y()
				 || abs( distance.z() ) > distanceLimitForConnection.z() )
					continue;

				ConnectedHit *connectedHit2 = 0;

				for( unsigned int c=0 ; c<connectedHitCollection->size() ; c++ ) {

					if( connectedHitCollection->at( c )->GetCaloHit() == caloHit2 ) {

						connectedHit2 = connectedHitCollection->at( c );
						break;
					}
				}

				if( connectedHit2 == 0 ) {
					connectedHit2 = new ConnectedHit();
					connectedHit2->SetCaloHit( caloHit2 );
				}

				double weight = distance.theta()*sqrt( distance.mag() );

				Connector *connector = new Connector();
				connector->Connect( connectedHit1 , connectedHit2 , weight );
				connectedHit1->AddConnector( connector );
				connectedHit2->AddConnector( connector );

			}

			connectedHitCollection->push_back( connectedHit1 );
		}

		return BABOON_SUCCESS();
	}




	Return ShowerAgglomerationAlgorithm::CleanConnectors() {



		for( unsigned int c=0 ; c<connectedHitCollection->size() ; c++ ) {

//			ConnectedHitCollection forwardConnectedHits;
			ConnectorCollection &connectors = connectedHitCollection->at( c )->GetConnectors();

			if( connectors.empty() )
				continue;

			cout << endl;
			CaloHit *theHit = connectedHitCollection->at( c )->GetCaloHit();
			ThreeVector hitPosition = theHit->GetPosition();
//			cout << "IJK hit : " << theHit->GetIJK().at(0) << " " << theHit->GetIJK().at(1) << " " << theHit->GetIJK().at(2) << endl;
			ThreeVector referenceVector(0,0,0);
			double meanMag = 0;

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {


				Connector *connector = connectors.at( co );
				CaloHit *otherHit = connector->GetSecond()->GetCaloHit();
				ThreeVector otherHitPosition = otherHit->GetPosition();

				if( otherHitPosition.z() <= hitPosition.z() )
					continue;

				ThreeVector difference = otherHitPosition - hitPosition;
				referenceVector.setX( referenceVector.x() + difference.x() );
				referenceVector.setY( referenceVector.y() + difference.y() );
				referenceVector.setZ( referenceVector.z() + difference.z() );
				meanMag += difference.mag();

//				cout << "IJK otherHit : " << otherHit->GetIJK().at(0) << " " << otherHit->GetIJK().at(1) << " " << otherHit->GetIJK().at(2) << endl;
//				cout << "connector weight : " << connector->GetWeight() <<  endl;
			}

			if( meanMag != 0 ) {
				meanMag /= connectors.size();
				referenceVector.setMag( meanMag );
			}

			Connector *bestConnector = 0;
			double bestOrderParameter = 10;

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

				Connector *connector = connectors.at( co );
				CaloHit *otherHit = connector->GetSecond()->GetCaloHit();
				ThreeVector otherHitPosition = otherHit->GetPosition();

				if( otherHitPosition.z() <= hitPosition.z() )
					continue;

				ThreeVector difference = otherHitPosition - hitPosition;

				if( difference.angle( referenceVector ) < bestOrderParameter ) {

					if( bestConnector != 0 ) {
						connectedHitCollection->at( c )->RemoveConnector( bestConnector );
						co--;
					}

					bestOrderParameter = difference.angle( referenceVector );
					bestConnector = connector;

				}
				else {
					connectedHitCollection->at( c )->RemoveConnector( connector );
					co--;
				}



//				cout << "IJK otherHit : " << otherHit->GetIJK().at(0) << " " << otherHit->GetIJK().at(1) << " " << otherHit->GetIJK().at(2) << endl;
//				cout << "connector weight : " << difference.angle( referenceVector ) <<  endl;
			}

			cout << "Nb of connectors at the end : " << connectors.size() << endl;

			/*
			 * A faire :
			 *
			 *
			 * Visualiser le resultat dans le monitoring
			 *
			 */

		}

		return BABOON_SUCCESS();
	}



	Return ShowerAgglomerationAlgorithm::DrawConnectors() {

		for( unsigned int c=0 ; c<connectedHitCollection->size() ; c++ ) {

			ConnectorCollection &connectors = connectedHitCollection->at( c )->GetConnectors();
			CaloHit *theHit = connectedHitCollection->at( c )->GetCaloHit();
			ThreeVector hitPosition = theHit->GetPosition();
			IntVector ijk = theHit->GetIJK();

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

				Connector *connector = connectors.at( co );
				CaloHit *otherHit = connector->GetSecond()->GetCaloHit();
				ThreeVector otherHitPosition = otherHit->GetPosition();
				IntVector ijkOther = otherHit->GetIJK();

//				if( otherHitPosition.z() <= hitPosition.z() )
//					continue;

				this->DrawEveArrow( ijk.at(0) , ijk.at(1) , ijk.at(2) ,
									 ijkOther.at(0) , ijkOther.at(1) , ijkOther.at(2) ,
									 kRed );

			}
		}

		return BABOON_SUCCESS();
	}

	void ShowerAgglomerationAlgorithm::DrawEveArrow( double I1 , double J1 , double K1 ,
											  double I2 , double J2 , double K2 ,
											  int color ) {

		unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
		double cellSize0 = calorimeter->GetCellSize0();
		double cellSize1 = calorimeter->GetCellSize1();
		double layerThickness = calorimeter->GetLayerThickness();
		double absorberThickness = calorimeter->GetAbsorberThickness();
		int repeatX = calorimeter->GetRepeatX();
		int repeatY = calorimeter->GetRepeatY();

		double shiftXFactor = cellSize0*repeatX / 2.0;
		double shiftYFactor = cellSize1*repeatY / 2.0;
		double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

		if( BaboonMonitoring::IsEnable() && gEve ) {

			TEveArrow *connectionArrow = new TEveArrow( cellSize0*I2-cellSize0*I1
													  , cellSize1*J2-cellSize1*J1
													  , layerThickness*K2-layerThickness*K1
													  , cellSize0*I1 - shiftXFactor
													  , cellSize1*J1 - shiftYFactor
													  , layerThickness*K1 + shiftZFactor );

			connectionArrow->SetMainColor( color );
			connectionArrow->SetPickable( true );
			connectionArrow->SetTubeR( 0.05 );
			connectionArrow->SetConeR( 0.008 );
			connectionArrow->SetConeL( 0.008 );
			BaboonMonitoring::GetInstance()->AddElement( connectionArrow );
		}

	}



	Return ShowerAgglomerationAlgorithm::End() {

		calorimeter = 0;
		return BABOON_SUCCESS();
	}


	Return ShowerAgglomerationAlgorithm::SetCalorimeter( Calorimeter *calo ) {

		BABOON_CHECK_POINTER( calo );
		calorimeter = calo;
		return BABOON_SUCCESS();
	}


}  // namespace 

