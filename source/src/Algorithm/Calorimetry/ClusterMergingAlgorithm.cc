  /// \file ClusterMergingAlgorithm.cc
/*
 *
 * ClusterMergingAlgorithm.cc source template generated by fclass
 * Creation date : ven. dï¿½c. 13 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Remi Ete
 * @version
 * @copyright
 *
 *
 */


#include "Algorithm/Calorimetry/ClusterMergingAlgorithm.hh"

using namespace std;

namespace baboon {

	ClusterMergingAlgorithm::ClusterMergingAlgorithm()
		: AbstractAlgorithm("ClusterMergingAlgorithm") {

		needData = true;
	}

	ClusterMergingAlgorithm::~ClusterMergingAlgorithm() {

	}


	Return ClusterMergingAlgorithm::Init() {

		data.GetValue( "shouldMergeClusterWithSameStartingPoint" , &shouldMergeClusterWithSameStartingPoint );
		data.GetValue( "minimumClusterSizeMerging" , &minimumClusterSizeMerging );
		data.GetValue( "maximumClusterSizeMerging" , &maximumClusterSizeMerging );
		data.GetValue( "startingPointDistanceThreshold" , &startingPointDistanceThreshold );

		return BABOON_SUCCESS();
	}


	Return ClusterMergingAlgorithm::CheckConsistency() {

		return BABOON_SUCCESS();
	}


	Return ClusterMergingAlgorithm::Execute() {

		clusterCollection = ClusteringManager::GetInstance()->GetCluster3D();

		if( clusterCollection->empty() )
			return BABOON_SUCCESS();

		if( shouldMergeClusterWithSameStartingPoint )
			this->MergeSameClusterStartingPoint();

//		cout << "after starting point merging : " << clusterCollection->size() << endl;
//		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ )
//			cout << "cluster size : " << clusterCollection->at(cl)->Size() << endl;

		this->MergeSmallClusters();

//		cout << "after small cluster merging : " << clusterCollection->size() << endl;
		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			CaloHitCollection *clusterHits = clusterCollection->at(cl)->GetCaloHitCollection();
//			cout << "cluster size : " << clusterCollection->at(cl)->Size() << endl;

			for( unsigned int c1=0 ; c1<clusterHits->size() ; c1++ )
				clusterHits->at(c1)->SetColor( cl + 1 );
		}

		return BABOON_SUCCESS();
	}


	Return ClusterMergingAlgorithm::End() {

		return BABOON_SUCCESS();
	}




	void ClusterMergingAlgorithm::MergeSameClusterStartingPoint() {

		// here a cluster merging is done for each clusters that have the first calo hit
		// belonging to the same 2D cluster

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			Cluster *cluster = clusterCollection->at(cl);
			CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();
			std::sort( clusterHits->begin() , clusterHits->end() , CaloHit::SortByLayer );
		}

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			Cluster *cluster = clusterCollection->at(cl);
			CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();

			if( cluster->Size() <= minimumClusterSizeMerging )
				continue;

			for( unsigned int cl2=cl ; cl2<clusterCollection->size() ; cl2++ ) {

				if( cl == cl2 )
					continue;

				Cluster *cluster2 = clusterCollection->at(cl2);

				if( cluster2->Size() <= minimumClusterSizeMerging )
					continue;

				CaloHitCollection *clusterHits2 = cluster2->GetCaloHitCollection();
				CaloHit *firstCaloHitInCluster2 = clusterHits2->at(0);

				// if the calo hit belongs to the same 2D cluster, merge them

				for( unsigned int c=0 ; c<clusterHits->size() ; c++  ) {

					if( fabs( clusterHits->at(c)->GetPosition().x() - firstCaloHitInCluster2->GetPosition().x() ) < startingPointDistanceThreshold
					 && fabs( clusterHits->at(c)->GetPosition().y() - firstCaloHitInCluster2->GetPosition().y() ) < startingPointDistanceThreshold
					 && clusterHits->at(c)->GetIJK().at(2) == firstCaloHitInCluster2->GetIJK().at(2) ) {

						for( unsigned int clID=0 ; clID<cluster2->Size() ; clID++ )
							cluster->AddCaloHit( cluster2->GetCaloHitCollection()->at(clID) );

						cluster2->Clear();
						break;
					}
				}
			}
		}

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			if( clusterCollection->at(cl)->Size() == 0 ) {

				delete clusterCollection->at(cl);
				clusterCollection->erase( clusterCollection->begin() + cl );
				cl --;
			}
		}


	}


	void ClusterMergingAlgorithm::MergeSmallClusters() {

		// here is the merging of all the clusters that are too small to be considered as PFOs
		// A small cluster is merged in the closest big one.

		std::map<Cluster*,Cluster*> smallToBigClustersToMerge;

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			if( clusterCollection->at(cl)->Size() > maximumClusterSizeMerging )
				continue;

			Cluster *smallCluster = clusterCollection->at(cl);

			ThreeVector clusterPosition = smallCluster->GetPosition( fComputePosition );
			double minimumDistance = 100000000.0;
			Cluster *closestCluster = 0;

			for( unsigned int cl2=0 ; cl2<clusterCollection->size() ; cl2++ ) {

				if( clusterCollection->at(cl2)->Size() <= maximumClusterSizeMerging )
					continue;

				Cluster *cluster2 = clusterCollection->at(cl2);

				if( closestCluster == 0 ) {

					minimumDistance = cluster2->DistanceToMe( clusterPosition );
					closestCluster = cluster2;
					continue;
				}

				double distance = cluster2->DistanceToMe( clusterPosition );

				if( distance < minimumDistance ) {

					minimumDistance = distance;
					closestCluster = cluster2;
				}
			}
			smallToBigClustersToMerge[ smallCluster ] = closestCluster;
		}

		for( std::map<Cluster*,Cluster*>::iterator it=smallToBigClustersToMerge.begin() ;
			it!=smallToBigClustersToMerge.end() ; it++ ) {

			if( it->second == 0 || it->first == 0 )
				continue;

			CaloHitCollection *smallClusterHits = it->first->GetCaloHitCollection();

			for( unsigned int h1=0 ; h1<smallClusterHits->size() ; h1++ )
				it->second->AddCaloHit( smallClusterHits->at(h1) );

			std::vector<Cluster*>::iterator clIt = std::find( clusterCollection->begin() , clusterCollection->end() , it->first );
			delete (*clIt);
			clusterCollection->erase( clIt );
		}
		smallToBigClustersToMerge.clear();
	}


}  // namespace 

