  /// \file DensityClusteringAlgorithm.cc
/*
 *
 * DensityClusteringAlgorithm.cc source template generated by fclass
 * Creation date : lun. oct. 14 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : R�mi Et�
 * @version
 * @copyright
 *
 *
 */


#include "Algorithm/Calorimetry/DensityClusteringAlgorithm.hh"

using namespace std;

namespace baboon {


	DensityClusteringAlgorithm::DensityClusteringAlgorithm()
		: AbstractAlgorithm("DensityClusteringAlgorithm") {

		needData = true;
	}

	DensityClusteringAlgorithm::~DensityClusteringAlgorithm() {

	}


	Return DensityClusteringAlgorithm::Init() {

		data.GetValue("lowestDensityLimit",&lowestDensityLimit);
		data.GetValue("highestDensityLimit",&highestDensityLimit);
		data.GetValue("densityStep",&densityStep);
		data.GetValue("densityError",&densityError);

		return BABOON_SUCCESS();
	}

	Return DensityClusteringAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}

	Return DensityClusteringAlgorithm::Execute() {

		/*
		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// sort hits by decreasing densities
		std::sort( caloHitCollection->begin() , caloHitCollection->end() ,
				[&] ( CaloHit *caloHit1 , CaloHit *caloHit2 ) -> bool
				{ if( caloHit1->GetDensity() < caloHit2->GetDensity() ) return true;
				else return false; } );

		// Clusters the calo hits by density
		for( auto caloHit :*caloHitCollection ) {

			if( caloHit->GetTag() == TrackTag() )
				continue;

			if( std::find( treatedHits.begin() , treatedHits.end() , caloHit ) == treatedHits.end() ) {

				Cluster *newCluster = new Cluster();
				newCluster->SetClusterType( fCluster3D );
				treatedHits.push_back( caloHit );
				newCluster->AddCaloHit( caloHit );

				this->AgglomerateFromCaloHit( caloHit , newCluster );

				clusters.push_back( newCluster );
			}
		}


//		this->MergeClusters();



		cout << "Nb of clusters : " << clusters.size() << endl;

		for( auto cluster :clusters ) {

			Shower *newShower = new Shower();
			CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();

			ClusteringManager::GetInstance()->AddCluster( cluster );

			for( auto caloHit :*clusterHits )
				newShower->AddCaloHit( caloHit );

			ShowerManager::GetInstance()->AddShower( newShower );
		}
*/
		return BABOON_SUCCESS();
	}

	Return DensityClusteringAlgorithm::End() {

		treatedHits.clear();
		clusters.clear();
		calorimeter = 0;
		return BABOON_SUCCESS();
	}

	void DensityClusteringAlgorithm::AgglomerateFromCaloHit( CaloHit *caloHit , Cluster *cluster ) {

		IntVector ijk = caloHit->GetIJK();
		double density = caloHit->GetDensity();

		for( int i=-2 ; i<=2 ; i++ ) {
			for( int j=-2 ; j<=2 ; j++ ) {
				for( int k=-2 ; k<=2 ; k++ ) {

					if( !calorimeter->IsPadFired( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) )
						continue;

					CaloHit *otherCaloHit = calorimeter->GetCaloHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );

					if( otherCaloHit->GetTag() == TrackTag() )
						continue;

					if( density <= otherCaloHit->GetDensity()
						&& abs( density - otherCaloHit->GetDensity() ) < densityError ) {

						if( !cluster->Contains( otherCaloHit )
						&&  std::find( treatedHits.begin() , treatedHits.end() , otherCaloHit ) == treatedHits.end() ) {

							cluster->AddCaloHit( otherCaloHit );
							treatedHits.push_back( otherCaloHit );
							this->AgglomerateFromCaloHit( otherCaloHit , cluster );

						}
					}

				} // k
			} // j
		} // i

	}



	void DensityClusteringAlgorithm::MergeClusters() {





//		ThreeVector position = cluster->GetPosition();
//
//		Cluster *closestCluster = 0;
//		double closestDistance = 10000000.0;
//
//		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {
//
//			Cluster *otherCluster = clusterCollection->at( cl );
//
//			if( cluster == otherCluster )
//				continue;
//
//			double distance = (otherCluster->GetPosition() - position ).mag();
//
//			if( distance < closestDistance && distance < 5 ) {
//				closestDistance = distance;
//				closestCluster = otherCluster;
//			}
//		}
//
//		if( closestCluster == 0 )
//			return false;
//
//		CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();
//
//		for( unsigned int h=0 ; h<cluster->Size() ; h++ ) {
//
//			if( !closestCluster->Contains( clusterHits->at( h ) ) ) {
//				closestCluster->AddCaloHit( clusterHits->at( h ) );
//			}
//		}
//
//		return true;

	}

}  // namespace 

