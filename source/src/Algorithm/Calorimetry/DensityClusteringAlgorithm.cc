  /// \file DensityClusteringAlgorithm.cc
/*
 *
 * DensityClusteringAlgorithm.cc source template generated by fclass
 * Creation date : lun. oct. 14 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : R�mi Et�
 * @version
 * @copyright
 *
 *
 */


#include "Algorithm/Calorimetry/DensityClusteringAlgorithm.hh"

using namespace std;

namespace baboon {


	DensityClusteringAlgorithm::DensityClusteringAlgorithm()
		: AbstractAlgorithm("DensityClusteringAlgorithm") {

		needData = true;
	}

	DensityClusteringAlgorithm::~DensityClusteringAlgorithm() {

	}


	Return DensityClusteringAlgorithm::Init() {

		data.GetValue("lowestDensityLimit",&lowestDensityLimit);
		data.GetValue("highestDensityLimit",&highestDensityLimit);
		data.GetValue("densityStep",&densityStep);
		data.GetValue("densityError",&densityError);

		return BABOON_SUCCESS();
	}

	Return DensityClusteringAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}

	Return DensityClusteringAlgorithm::Execute() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();
		CaloHitCollection *hitSortedByDensity = new CaloHitCollection();

		for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {

			if( caloHitCollection->at( h )->GetTag() == IsolatedTag()
			|| caloHitCollection->at( h )->GetTag() == TrackTag() )
				continue;

			hitSortedByDensity->push_back( caloHitCollection->at( h ) );
		}



		CaloHit *caloHit = 0;
		int i = 0;
		int j = 0;

		for( j=1 ; j<hitSortedByDensity->size() ; j++ ) {

			i = j-1;

			while( hitSortedByDensity->at(j)->GetDensity() > hitSortedByDensity->at(i)->GetDensity() ) {

				caloHit = hitSortedByDensity->at(i);
				hitSortedByDensity->at(i) = hitSortedByDensity->at(j);
				hitSortedByDensity->at(j) = caloHit;
				i=i-1;
				j=j-1;

				if( i < 0 )
					break;
			}
		}

		ClusterCollection *clusterCollection = new ClusterCollection();

		for( unsigned int h=0 ; h<hitSortedByDensity->size() ; h++ ) {

			CaloHit *caloHit = hitSortedByDensity->at( h );

			if( std::find( treatedHits.begin() , treatedHits.end() , caloHit ) == treatedHits.end() ) {

				Cluster *cluster = new Cluster();
				cluster->AddCaloHit( caloHit );
				treatedHits.push_back( caloHit );
				this->AgglomerateFromCaloHit( caloHit , cluster );
				clusterCollection->push_back( cluster );
			}
			else {

				treatedHits.push_back( caloHit );
			}
		}


		Cluster *cluster = 0;
		i = 0;
		j = 0;

		for( j=1 ; j<clusterCollection->size() ; j++ ) {

			i = j-1;

			while( clusterCollection->at(j)->Size() < clusterCollection->at(i)->Size() ) {

				cluster = clusterCollection->at(i);
				clusterCollection->at(i) = clusterCollection->at(j);
				clusterCollection->at(j) = cluster;
				i=i-1;
				j=j-1;

				if( i < 0 )
					break;
			}
		}

		cout << "nb of clusters (before) : " << clusterCollection->size() <<  endl;

		SimpleEnergyCalculator *calculator = new SimpleEnergyCalculator();

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			CaloHitCollection *clusterHits = clusterCollection->at( cl )->GetCaloHitCollection();
			calculator->SetCaloHitCollection( clusterHits );
			calculator->CalculateEnergy();
			double energy = calculator->GetEnergy();
			cout << "cluster energy : " << energy << endl;

			if( energy < 0.8 ) { // in GeV

				bool hasBeenMerged = this->MergeWithClosestCluster( clusterCollection->at( cl ) , clusterCollection );

//				if( hasBeenMerged ) {

					delete clusterCollection->at( cl );
					clusterCollection->erase( clusterCollection->begin() + cl );
					cl--;
					continue;
//				}
			}

			cout << "cluster size : " << clusterHits->size() << endl;
			for( unsigned int h=0 ; h<clusterHits->size() ; h++ ) {
				clusterHits->at( h )->SetColor( cl +1 );
			}
		}

		delete calculator;

		cout << "nb of clusters (after) : " << clusterCollection->size() <<  endl;

		hitSortedByDensity->clear();

		return BABOON_SUCCESS();
	}

	Return DensityClusteringAlgorithm::End() {

		treatedHits.clear();
		calorimeter = 0;
		return BABOON_SUCCESS();
	}

	void DensityClusteringAlgorithm::AgglomerateFromCaloHit( CaloHit *caloHit , Cluster *cluster ) {

		IntVector ijk = caloHit->GetIJK();

		for( int i=-1 ; i<=1 ; i++ ) {
			for( int j=-1 ; j<=1 ; j++ ) {
				for( int k=-1 ; k<=1 ; k++ ) {

//					cout << i << " " << j << " " << k << endl;
					if( !calorimeter->IsPadFired( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) )
						continue;

					CaloHit *otherCaloHit = calorimeter->GetCaloHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );

					if( otherCaloHit->GetTag() == IsolatedTag()
					|| otherCaloHit->GetTag() == TrackTag() )
						continue;

					if( caloHit->GetDensity() >= otherCaloHit->GetDensity()
						|| abs( caloHit->GetDensity() - otherCaloHit->GetDensity() ) < densityError ) {

						if( !cluster->Contains( otherCaloHit )
						&&  std::find( treatedHits.begin() , treatedHits.end() , otherCaloHit ) == treatedHits.end() ) {

							cluster->AddCaloHit( otherCaloHit );
							treatedHits.push_back( otherCaloHit );
							this->AgglomerateFromCaloHit( otherCaloHit , cluster );
						}
					}

				} // k
			} // j
		} // i


	}



	bool DensityClusteringAlgorithm::MergeWithClosestCluster( Cluster *cluster , ClusterCollection *clusterCollection ) {

		ThreeVector position = cluster->GetPosition();

		Cluster *closestCluster = 0;
		double closestDistance = 10000000.0;

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			Cluster *otherCluster = clusterCollection->at( cl );

			if( cluster == otherCluster )
				continue;

			double distance = (otherCluster->GetPosition() - position ).mag();

			if( distance < closestDistance && distance < 5 ) {
				closestDistance = distance;
				closestCluster = otherCluster;
			}
		}

		if( closestCluster == 0 )
			return false;

		CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();

		for( unsigned int h=0 ; h<cluster->Size() ; h++ ) {

			if( !closestCluster->Contains( clusterHits->at( h ) ) ) {
				closestCluster->AddCaloHit( clusterHits->at( h ) );
			}
		}

		return true;

	}

}  // namespace 

