  /// \file TrackFinderAlgorithm.cc
/*
 *
 * TrackFinderAlgorithm.cc source template generated by fclass
 * Creation date : mar. oct. 8 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Et� R�mi
 * @version
 * @copyright
 *
 *
 */


#include "Algorithm/Calorimetry/TrackFinderAlgorithm.hh"

using namespace std;

namespace baboon {


	TrackFinderAlgorithm::Point::Point() {

		connectors = new ConnectorCollection();
	}


	TrackFinderAlgorithm::Point::~Point() {

		// no connector deletion since, there
		// are not created in the Point object
		connectors->clear();
		delete connectors;
	}

	void TrackFinderAlgorithm::Point::AddConnector( TrackFinderAlgorithm::Connector *connector ) {

		if( connector == 0 )
			return;

		if( !this->IsConnectedTo( connector ) ) {
			connectors->push_back( connector );
		}
		return;

	}


	void TrackFinderAlgorithm::Point::RemoveConnector( TrackFinderAlgorithm::Connector *connector ) {

		if( connector == 0 )
			return;

		std::vector<TrackFinderAlgorithm::Connector*>::iterator it = std::find( connectors->begin() , connectors->end() , connector );
		if( it != connectors->end() ) {
			connectors->erase( it );
		}
		return;

	}


	bool TrackFinderAlgorithm::Point::IsConnectedTo( Connector *connector ) {

		return ( std::find( connectors->begin() , connectors->end() , connector ) != connectors->end() );
	}


	bool TrackFinderAlgorithm::Point::IsConnectedTo( Point *point ) {

		for( unsigned int c=0 ; c<connectors->size() ; c++ )
			if( connectors->at( c )->GetSecond() == point )
				return true;

		return false;
	}



	void TrackFinderAlgorithm::Point::SetCluster( Cluster *cl ) {

		cluster = cl;
	}


	Cluster *TrackFinderAlgorithm::Point::GetCluster() {

		return cluster;
	}



	bool TrackFinderAlgorithm::Point::HasNoConnection() {

		return connectors->empty();
	}



	TrackFinderAlgorithm::ConnectorCollection *TrackFinderAlgorithm::Point::GetConnectors() {

		return connectors;
	}


	int TrackFinderAlgorithm::Point::HowManyBackwardConnectors() {

		int count = 0;

		for( unsigned int c=0 ; c<connectors->size() ; c++ )
			if( connectors->at( c )->GetSecond()->GetCluster()->GetPosition().z() < cluster->GetPosition().z() )
				count++;

		return count;
	}



	int TrackFinderAlgorithm::Point::HowManyForwardConnectors() {

		int count = 0;

		for( unsigned int c=0 ; c<connectors->size() ; c++ )
			if( connectors->at( c )->GetSecond()->GetCluster()->GetPosition().z() > cluster->GetPosition().z() )
				count++;

		return count;
	}

	// -----------------------------------------------------------------------------------------------------

	void TrackFinderAlgorithm::Connector::Connect( Point *point1 , Point *point2 ) {

		if( point1 == 0 || point2 == 0 )
			return;

		pointPair.first = point1;
		pointPair.second = point2;
	}


	void TrackFinderAlgorithm::Connector::Disconnect() {

		pointPair.first = 0;
		pointPair.second = 0;
	}


	TrackFinderAlgorithm::Point *TrackFinderAlgorithm::Connector::GetFirst() {

		return pointPair.first;
	}


	TrackFinderAlgorithm::Point *TrackFinderAlgorithm::Connector::GetSecond() {

		return pointPair.second;
	}

//-------------------------------------------------------------------------------------------------

	TrackFinderAlgorithm::TrackFinderAlgorithm()
		: AbstractAlgorithm("TrackFinderAlgorithm") {

		needData = true;
		allPoints = new PointCollection();
		connectorCollection = new ConnectorCollection();
		pointHelpers = new PointHelperCollection();
	}

	TrackFinderAlgorithm::~TrackFinderAlgorithm() {

		delete allPoints;
		delete connectorCollection;
		delete pointHelpers;
	}


	Return TrackFinderAlgorithm::Init() {

		data.GetValue( "clusterSizeLimit" , &clusterSizeLimit );
		data.GetValue( "minimumTrackSize" , &minimumTrackSize );
		data.GetValue( "lookupDistanceX" , &lookupDistanceX );
		data.GetValue( "lookupDistanceY" , &lookupDistanceY );
		data.GetValue( "lookupDistanceZ" , &lookupDistanceZ );
		data.GetValue( "maximumConnectorsAngle" , &maximumConnectorsAngle );
		data.GetValue( "drawConnectors" , &drawConnectors);

		return BABOON_SUCCESS();
	}



	Return TrackFinderAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}



	Return TrackFinderAlgorithm::Execute() {

		ClusteringManager *clusteringManager = ClusteringManager::GetInstance();
		ClusterCollection *clusters2D = clusteringManager->GetCluster2D();

		// Return if there's no 2D clusters
		if( clusters2D->empty() )
			return BABOON_SUCCESS();

		unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
		double cellSize0 = calorimeter->GetCellSize0();
		double cellSize1 = calorimeter->GetCellSize1();
		double layerThickness = calorimeter->GetLayerThickness();
		double absorberThickness = calorimeter->GetAbsorberThickness();
		int repeatX = calorimeter->GetRepeatX();
		int repeatY = calorimeter->GetRepeatY();

		double shiftXFactor = cellSize0*repeatX / 2.0;
		double shiftYFactor = cellSize1*repeatY / 2.0;
		double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;


		// Keep all the clusters that can be contained in tracks

		OrderedPointCollection *orderedPoints = new OrderedPointCollection();

		for( unsigned int cl=0 ; cl<clusters2D->size() ; cl++ ) {

			Cluster *cluster = clusters2D->at( cl );

			// Keep or not the cluster. See the function itself
			if( !this->KeepCluster( cluster , clusters2D ) )
				continue;

			CaloHitCollection *caloHitCol = cluster->GetCaloHitCollection();
			unsigned int clusterLayer = cluster->GetCaloHitCollection()->at(0)->GetIJK().at(2);

			Point *point = new Point();
			point->SetCluster( cluster );

			if( (*orderedPoints)[ clusterLayer ] == 0 ) {
				(*orderedPoints)[ clusterLayer ] = new PointCollection();
			}

			(*orderedPoints)[ clusterLayer ]->push_back( point );
			allPoints->push_back( point );

		}

		for( unsigned int l=0 ; l<nbOfLayers ; l++ ) {

			if( (*orderedPoints)[ l ] == 0 )
				continue;

			PointCollection *pointsInLayer = (*orderedPoints)[ l ];

			for( unsigned int p=0 ; p<pointsInLayer->size() ; p++ ) {

				Point *pointInLayer = pointsInLayer->at( p );

				for( unsigned int nextL=l+1 ; (nextL-l)<=lookupDistanceZ ; nextL++ ) {

					if( nextL > nbOfLayers )
						continue;

					PointCollection *nextPointCollection = (*orderedPoints)[ nextL ];

					bool found = this->ConnectWithLayer( pointInLayer , nextPointCollection );

					if( found )
						break;
				}

			}
		}

		// Here all the possible connections are made. We need to remove some of them
		// and keep only real track connectors and so track points

		for( unsigned int p=0 ; p<allPoints->size() ; p++ ) {

			Point *point = allPoints->at( p );

			int nbOfForwardConnections = point->HowManyForwardConnectors();

			// If no connection is the next planes,
			// the cluster is not a good one to start with.
			if( nbOfForwardConnections == 0 )
				continue;

			// Use a struct with the needed information to follow the connectors
			PointHelper *pointHelper = new PointHelper();
			pointHelper->point = point;
			pointHelper->forwardPoint = 0;
			pointHelper->forwardConnector = 0;
			pointHelper->pointCollection = new PointCollection();
			pointHelper->pointCollection->push_back( point );
			pointHelper->isFirstPoint = true;

			pointHelpers->push_back( pointHelper );

			// The recursive function ...
			this->FindPotentialTrack( pointHelper );

		}


		this->SortPotentialTracksBySize();


		std::vector<PointCollection *> finalTracks;
		PointCollection treatedPoints;

		for( unsigned int pt=0 ; pt<potentialTrackPoints.size() ; pt++ ) {

			PointCollection *potentialTrack = potentialTrackPoints.at( pt );

			if( pt == 0 ) {
				finalTracks.push_back( potentialTrack );
				treatedPoints = PointCollection( *potentialTrack );
			}
			else {

				// Check if some points are already used by treated tracks
				for( unsigned int p=0 ; p<potentialTrack->size() ; p++ ) {

					Point *point = potentialTrack->at( p );

					if( std::find( treatedPoints.begin() , treatedPoints.end() , point ) != treatedPoints.end() ) {

						potentialTrack->erase( potentialTrack->begin()+p );
						p --;
					}
				}

				// Keep the track if after removing the redundant clusters the track is long enough
				if( potentialTrack->size() >= minimumTrackSize ) {

					// First, find if there is a hole in the track, that is to
					// say a track with at least two empty layers. In this case,
					// delete this track ...
					this->SortPointsByLayer( potentialTrack );
					bool shouldKeep = true;

					for( unsigned int p=0 ; p<potentialTrack->size() ; p++ ) {

						if( p != potentialTrack->size() - 1 ) {

							Point *point = potentialTrack->at( p );
							Point *nextPoint = potentialTrack->at( p+1 );

							if( abs( point->GetCluster()->GetPosition().z() - nextPoint->GetCluster()->GetPosition().z() ) > 2 ) {
								shouldKeep = false;
								break;
							}
						}
					}

					// ... else keep this track ! This is a good one !
					if( shouldKeep ) {
						finalTracks.push_back( potentialTrack );

						for( unsigned int p=0 ; p<potentialTrack->size() ; p++ ) {
							treatedPoints.push_back( potentialTrack->at( p ) );
						}
					} // shouldKeep
				} // if minimumTrackSize
			} // else
		} // for

		// Here the tracks are made.
		// We need to create "Track *" objects and register them in the TrackManager.
		TrackCollection tempTrackCollection;

		for( unsigned int pt=0 ; pt<finalTracks.size() ; pt++ ) {

			PointCollection *trackPoints = finalTracks.at( pt );
//			ClusterCollection *trackClusters = finalTracks.at( pt );
			Track *track = new Track();

			for( unsigned int cl=0 ; cl<trackPoints->size() ; cl++ ) {

				CaloHitCollection *clusterHits = trackPoints->at( cl )->GetCluster()->GetCaloHitCollection();

				for( unsigned int h=0 ; h<clusterHits->size() ; h++ ) {

					BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , track->AddCaloHit( clusterHits->at(h) ) );
					clusterHits->at(h)->SetTag( TrackTag() );
				}
			}

			if( drawConnectors )
				this->DrawTrackConnectors( trackPoints , pt+1 );

			track->SortHits();
			CaloHitCollection *trackHits = track->GetCaloHitCollection();
			int lastTrackLayer = track->GetCaloHitCollection()->at( track->Size() - 1 )->GetIJK().at(2);
			int firstTrackLayer = track->GetCaloHitCollection()->at( 0 )->GetIJK().at(2);

			ClusterCollection trackClusters;
			Cluster *currentCluster = new Cluster();

			for( unsigned int h=0 ; h<trackHits->size() ; h++ ) {

				CaloHit *caloHit = trackHits->at( h );
				if( h == trackHits->size() - 1 ) {
					currentCluster->AddCaloHit( caloHit );
					trackClusters.push_back( currentCluster );
					break;
				}

				CaloHit *hit = trackHits->at( h );
				CaloHit *nextHit = trackHits->at( h+1 );

				if( hit->GetIJK().at(2) == nextHit->GetIJK().at(2) ) {
					currentCluster->AddCaloHit( hit );
					continue;
				}
				else {
					currentCluster->AddCaloHit( hit );
					trackClusters.push_back( currentCluster );
					currentCluster = new Cluster();
				}
			}

			currentCluster = 0;

			ThreeVector tempBackwardThrust;
			ThreeVector tempForwardThrust;

			for( unsigned int cl=0 ; cl<trackClusters.size() ; cl++ ) {

				if( cl == 0 )
					track->SetBeginPosition( trackClusters.at( cl )->GetPosition( fComputePosition ) );

				if( cl == trackClusters.size() - 1 ) {
					track->SetEndPosition( trackClusters.at( cl )->GetPosition( fComputePosition ) );
					break;
				}

				Cluster *cluster = trackClusters.at( cl );
				Cluster *nextCluster = trackClusters.at( cl+1 );
				ThreeVector difference = nextCluster->GetPosition( fComputePosition ) - cluster->GetPosition( fComputePosition );

				if( difference.z() < 0 )
					difference = -difference;

				// for the track beginning
				if( cl < 4 ) {
					tempBackwardThrust += difference;

				}
				// for the track end
				if( cl > trackClusters.size() - 4 ) {
					tempForwardThrust += difference;
				}
			}

			if( tempBackwardThrust != ThreeVector() )
				tempBackwardThrust.setMag( 1.f );
			if( tempForwardThrust != ThreeVector() )
				tempForwardThrust.setMag( 1.f );

			if( tempBackwardThrust.z() > 0 )
				tempBackwardThrust = -tempBackwardThrust;
			if( tempForwardThrust.z() < 0 )
				tempForwardThrust = -tempForwardThrust;

			track->SetBackwardThrust( tempBackwardThrust );
			track->SetForwardThrust( tempForwardThrust );

			tempTrackCollection.push_back( track );

			for( unsigned int cl=0 ; cl<trackClusters.size() ; cl++ ) {
				if( trackClusters.at( cl ) != 0 )
					delete trackClusters.at( cl );
			}
			trackClusters.clear();

		}

		double angle1 = 0.14;
		double angle2 = 0.14;
		double difPos = 100;


		// TO DO :
		// Comparer le début des deux traces en cours.


		// Broken track correction
		for( unsigned int tr1=0 ; tr1<tempTrackCollection.size() ; tr1++ ) {

			Track *track1 = tempTrackCollection.at( tr1 );
			if( track1 == 0 )
				continue;

			for( unsigned int tr2=0 ; tr2<tempTrackCollection.size() ; tr2++ ) {

				if( tr1 == tr2 )
					continue;

				Track *track2 = tempTrackCollection.at( tr2 );

				if( track2 == 0 )
					continue;

//				if( track1 == 0 )
//					continue;

//				cout << endl;
//				cout << "Track 1 end : " << track1->GetEndPosition()/26.131 << endl;
//				cout << "Track 2 begin : " << track2->GetBeginPosition()/26.131 << endl;
//				cout << "Angle 1 of : ";
//				cout << track1->GetForwardThrust().angle( -track2->GetBackwardThrust() ) << endl;
//				cout << " , an angle 2 of : ";
//				cout << track1->GetForwardThrust().angle( track2->GetBeginPosition() - track1->GetEndPosition() ) << endl;
//				cout << " and a pos dif of : ";
//				cout << (track1->GetEndPosition() - track2->GetBeginPosition() ).mag() << endl;
//				cout << endl;

				if( track1->GetForwardThrust().angle( -track2->GetBackwardThrust() ) < angle1
//					&& track1->GetForwardThrust().angle( track2->GetBeginPosition() - track1->GetEndPosition() ) < angle2
					&& (track1->GetEndPosition() - track2->GetBeginPosition() ).mag() < difPos ) {


					for( unsigned int h=0 ; h<track2->Size() ; h++ ) {
						track1->AddCaloHit( track2->GetCaloHitCollection()->at( h ) );
					}

//					cout << "!!! FOUND !!!" << endl;
//					cout << "Track 1 end : " << track1->GetEndPosition()/26.131 << endl;
//					cout << "Track 2 begin : " << track2->GetBeginPosition()/26.131 << endl;
//					cout << "Broken tracks compatibles with an angle 1 of : ";
//					cout << track1->GetForwardThrust().angle( -track2->GetBackwardThrust() ) << endl;
//					cout << " , an angle 2 of : ";
//					cout << track1->GetForwardThrust().angle( track2->GetBeginPosition() - track1->GetEndPosition() ) << endl;
//					cout << " and a pos dif of : ";
//					cout << (track1->GetEndPosition() - track2->GetBeginPosition() ).mag() << endl;

					track1->SetEndPosition( track2->GetEndPosition() );
					track1->SetForwardThrust( track2->GetForwardThrust() );
					delete track2;
					tempTrackCollection.at( tr2 ) = 0;

				}
				else if( track2->GetForwardThrust().angle( -track1->GetBackwardThrust() ) < angle1
	//					&& track1->GetForwardThrust().angle( track2->GetBeginPosition() - track1->GetEndPosition() ) < angle2
					&& ( track2->GetEndPosition() - track1->GetBeginPosition() ).mag() < difPos ) {


					for( unsigned int h=0 ; h<track1->Size() ; h++ ) {
						track2->AddCaloHit( track1->GetCaloHitCollection()->at( h ) );
					}

//					cout << "!!! FOUND !!!" << endl;
//					cout << "Track 1 begin : " << track1->GetBeginPosition()/26.131 << endl;
//					cout << "Track 2 end : " << track2->GetEndPosition()/26.131 << endl;
//					cout << "Broken tracks compatibles with an angle 1 of : ";
//					cout << track2->GetForwardThrust().angle( -track1->GetBackwardThrust() ) << endl;
//					cout << " , an angle 2 of : ";
//					cout << track2->GetForwardThrust().angle( track1->GetBeginPosition() - track2->GetEndPosition() ) << endl;
//					cout << " and a pos dif of : ";
//					cout << (track2->GetEndPosition() - track1->GetBeginPosition() ).mag() << endl;

					track2->SetEndPosition( track1->GetEndPosition() );
					track2->SetForwardThrust( track1->GetForwardThrust() );
					delete track1;
					tempTrackCollection.at( tr1 ) = 0;
					break;
				}
			}
		}


//		cout << "nb of tracks (before) : " << tempTrackCollection.size() << endl;

		for( unsigned int tr=0 ; tr<tempTrackCollection.size() ; tr++ ) {

			if( tempTrackCollection.at( tr ) != 0 ) {
				BABOON_THROW_RESULT_IF( BABOON_SUCCESS() , != , TrackManager::GetInstance()->AddTrack( tempTrackCollection.at( tr ) ) );
			}

//			if( drawConnectors )
//				this->DrawTrackConnectors( trackPoints , pt+1 );
		}

//		cout << "nb of tracks (after): " << TrackManager::GetInstance()->GetTrackCollection()->size() << endl;
		tempTrackCollection.clear();

		// deletion area

		for( unsigned int c=0 ; c<connectorCollection->size() ; c++ ) {

			if( connectorCollection->at( c ) != 0 ) {

				delete connectorCollection->at( c );
			}
		}

		connectorCollection->clear();


		for( unsigned int p=0 ; p<pointHelpers->size() ; p++ ) {

			if( pointHelpers->at( p ) != 0 ) {

				pointHelpers->at( p )->pointCollection->clear();
				delete pointHelpers->at( p )->pointCollection;
				delete pointHelpers->at( p );
			}
		}

		pointHelpers->clear();

		for( unsigned int p=0 ; p<allPoints->size() ; p++ ) {

			if( allPoints->at( p ) != 0 ) {
				delete allPoints->at( p );
			}
		}
		allPoints->clear();

		for( unsigned int pt=0 ; pt<potentialTrackPoints.size() ; pt++ ) {

			potentialTrackPoints.at( pt )->clear();
			delete potentialTrackPoints.at( pt );
		}
		potentialTrackPoints.clear();


		OrderedPointCollection::iterator it;

		for( it=orderedPoints->begin() ; it!=orderedPoints->end() ; it++ ) {

			if( it->second != 0 ) {
				it->second->clear();
				delete it->second;
			}
		}
		orderedPoints->clear();

		return BABOON_SUCCESS();

	}



	Return TrackFinderAlgorithm::End() {

		calorimeter = 0;
//		VALGRIND_DO_QUICK_LEAK_CHECK;
		return BABOON_SUCCESS();
	}


	bool TrackFinderAlgorithm::KeepCluster( Cluster *cluster , ClusterCollection *clusterCollection ) {

		if( cluster == 0 )
			return false;

		if( cluster->Size() > clusterSizeLimit )
			return false;

		if( clusterCollection == 0 )
			return true;

		ThreeVector clusterPosition = cluster->GetPosition();
		int neighborClusters = 0;

		for( unsigned int cl=0 ; cl<clusterCollection->size() ; cl++ ) {

			Cluster *otherCluster = clusterCollection->at( cl );

			if( otherCluster == cluster )
				continue;

			ThreeVector otherClusterPosition = otherCluster->GetPosition();

			// look in the same layer
			if( otherClusterPosition.z() != clusterPosition.z() )
				continue;

			if( abs( otherClusterPosition.x() - clusterPosition.x() ) < 4
			 && abs( otherClusterPosition.y() - clusterPosition.y() ) < 4 ) {

				neighborClusters++;

				if( otherCluster->Size() > clusterSizeLimit )
					return false;
			}

			if( neighborClusters == 3 )
				return false;

		}

		return true;
	}


	bool TrackFinderAlgorithm::ConnectWithLayer( Point *point , PointCollection *pointCollection ) {

		bool found = false;

		if( pointCollection == 0 )
			return false;

		if( pointCollection->empty() )
			return false;

		ThreeVector clusterPosition = point->GetCluster()->GetPosition();

		for( unsigned int p=0 ; p<pointCollection->size() ; p++ ) {

			Point *pointInNextLayer = pointCollection->at( p );
			Cluster *clusterInLayer = pointInNextLayer->GetCluster();
			ThreeVector clusterInLayerPosition = clusterInLayer->GetPosition();

			if( abs( clusterInLayerPosition.x() - clusterPosition.x() ) > lookupDistanceX
			 || abs( clusterInLayerPosition.y() - clusterPosition.y() ) > lookupDistanceY
			 || abs( clusterInLayerPosition.z() - clusterPosition.z() ) > lookupDistanceZ )
				continue;

			found = true;

			if( !point->IsConnectedTo( pointInNextLayer ) && !pointInNextLayer->IsConnectedTo( point ) ) {

				Connector *connector = new Connector();
				connector->Connect( point , pointInNextLayer );

				point->AddConnector( connector );
				pointInNextLayer->AddConnector( connector );
				connectorCollection->push_back( connector );
			}

		}

		return found;
	}

	void TrackFinderAlgorithm::FindPotentialTrack( PointHelper *pointHelper ) {

		double cellSize0 = calorimeter->GetCellSize0();
		double cellSize1 = calorimeter->GetCellSize1();
		double layerThickness = calorimeter->GetLayerThickness();

		if( pointHelper->isFirstPoint ) {

			Point *point = pointHelper->point;
			Cluster *cluster = pointHelper->point->GetCluster();
			ThreeVector clusterPosition = cluster->GetPosition();
			clusterPosition.setX( clusterPosition.x()*cellSize0 );
			clusterPosition.setY( clusterPosition.y()*cellSize1 );
			clusterPosition.setZ( clusterPosition.z()*layerThickness );

			ConnectorCollection *connectors = pointHelper->point->GetConnectors();

			for( unsigned int c=0 ; c<connectors->size() ; c++ ) {

				Connector *connector = connectors->at( c );

				Point* nextPoint = connector->GetSecond();
				Cluster *nextCluster = connector->GetSecond()->GetCluster();
				ThreeVector nextClusterPosition = nextCluster->GetPosition();
				nextClusterPosition.setX( nextClusterPosition.x()*cellSize0 );
				nextClusterPosition.setY( nextClusterPosition.y()*cellSize1 );
				nextClusterPosition.setZ( nextClusterPosition.z()*layerThickness );

				if( cluster->GetPosition().z() >= nextCluster->GetPosition().z() )
					continue;

				ConnectorCollection *nextConnectors = nextPoint->GetConnectors();

				bool connectorFound = false;
				double bestAngle = 10.0;
				Connector *bestNextConnector = 0;
				Point *bestNextPoint = 0;

				for( unsigned int c2=0 ; c2<nextConnectors->size() ; c2++ ) {

					Connector *nextConnector = nextConnectors->at( c2 );
					Point *nextNextPoint = nextConnector->GetSecond();
					Cluster *nextNextCluster = nextNextPoint->GetCluster();
					ThreeVector nextNextClusterPosition = nextNextCluster->GetPosition();

					nextNextClusterPosition.setX( nextNextClusterPosition.x()*cellSize0 );
					nextNextClusterPosition.setY( nextNextClusterPosition.y()*cellSize1 );
					nextNextClusterPosition.setZ( nextNextClusterPosition.z()*layerThickness );

					if( nextClusterPosition.z() >= nextNextClusterPosition.z() )
						continue;

					ThreeVector x1 = nextClusterPosition - clusterPosition;
					ThreeVector x2 = nextNextClusterPosition - nextClusterPosition;
					double angle = x1.angle( x2 );

					if( angle < bestAngle ) {

						bestAngle = angle;
						bestNextConnector = nextConnector;
						bestNextPoint = nextNextPoint;
					}
				}

				if( bestAngle > maximumConnectorsAngle ) {

					bestAngle = 10.0;
					bestNextConnector = 0;
					bestNextPoint = 0;
					continue;
				}

				pointHelper->isFirstPoint = false;
				pointHelper->point = nextPoint;
				pointHelper->forwardPoint = bestNextPoint;
				pointHelper->forwardConnector = bestNextConnector;
				pointHelper->pointCollection->push_back( nextPoint );

				this->FindPotentialTrack( pointHelper );

				pointHelper->isFirstPoint = true;
				pointHelper->point = point;
				pointHelper->forwardPoint = 0;
				pointHelper->forwardConnector = 0;
				pointHelper->pointCollection->clear();
			}



		} // end isFirstPoint
		else {

			Point *point = pointHelper->point;
			Cluster *cluster = point->GetCluster();
			ThreeVector clusterPosition = cluster->GetPosition();
			clusterPosition.setX( clusterPosition.x()*cellSize0 );
			clusterPosition.setY( clusterPosition.y()*cellSize1 );
			clusterPosition.setZ( clusterPosition.z()*layerThickness );

			Connector *forwardConnector = pointHelper->forwardConnector;
			Point *nextPoint = pointHelper->forwardPoint;
			Cluster *nextCluster = nextPoint->GetCluster();
			ThreeVector nextClusterPosition = nextCluster->GetPosition();
			nextClusterPosition.setX( nextClusterPosition.x()*cellSize0 );
			nextClusterPosition.setY( nextClusterPosition.y()*cellSize1 );
			nextClusterPosition.setZ( nextClusterPosition.z()*layerThickness );

			ConnectorCollection *nextConnectors = nextPoint->GetConnectors();

			double bestAngle = 10.0;
			Connector *bestNextConnector = 0;
			Point *bestNextPoint = 0;

			for( unsigned int c2=0 ; c2<nextConnectors->size() ; c2++ ) {

				Connector *nextConnector = nextConnectors->at( c2 );
				Point *nextNextPoint = nextConnector->GetSecond();
				Cluster *nextNextCluster = nextNextPoint->GetCluster();
				ThreeVector nextNextClusterPosition = nextNextCluster->GetPosition();

				nextNextClusterPosition.setX( nextNextClusterPosition.x()*cellSize0 );
				nextNextClusterPosition.setY( nextNextClusterPosition.y()*cellSize1 );
				nextNextClusterPosition.setZ( nextNextClusterPosition.z()*layerThickness );

				if( nextCluster->GetPosition().z() >= nextNextCluster->GetPosition().z() )
					continue;

				ThreeVector x1 = nextClusterPosition - clusterPosition;
				ThreeVector x2 = nextNextClusterPosition - nextClusterPosition;
				double angle = x1.angle( x2 );

				if( angle < bestAngle ) {

					bestAngle = angle;
					bestNextConnector = nextConnector;
					bestNextPoint = nextNextPoint;
				}
			}

			if( bestAngle > maximumConnectorsAngle ) {

				if( pointHelper->pointCollection->size() >= minimumTrackSize-1 ) {

					pointHelper->pointCollection->push_back( nextPoint );
					PointCollection *potentialTrack = new PointCollection( *pointHelper->pointCollection );
					potentialTrackPoints.push_back( potentialTrack );
				}
				return;
			}

			unsigned int oldSize = pointHelper->pointCollection->size();

			pointHelper->isFirstPoint = false;
			pointHelper->point = nextPoint;
			pointHelper->forwardPoint = bestNextPoint;
			pointHelper->forwardConnector = bestNextConnector;
			pointHelper->pointCollection->push_back( nextPoint );

			this->FindPotentialTrack( pointHelper );

			if( pointHelper->pointCollection->size() != oldSize ) {
				pointHelper->pointCollection->erase( pointHelper->pointCollection->begin() + oldSize , pointHelper->pointCollection->end() );
			}

			pointHelper->isFirstPoint = false;
			pointHelper->point = point;
			pointHelper->forwardPoint = nextPoint;
			pointHelper->forwardConnector = forwardConnector;
		}
	}

	void TrackFinderAlgorithm::SortPotentialTracksBySize() {

		int i = 0;
		int j = 0;
		PointCollection *pointCollection = 0;

		for( j=1 ; j<potentialTrackPoints.size() ; j++ ) {

			i = j-1;

			while( potentialTrackPoints.at(j)->size() > potentialTrackPoints.at(i)->size() ) {

				pointCollection = potentialTrackPoints.at(i);
				potentialTrackPoints.at(i) = potentialTrackPoints.at(j);
				potentialTrackPoints.at(j) = pointCollection;
				i=i-1;
				j=j-1;

				if( i < 0 )
					break;
			}
		}
	}



	void TrackFinderAlgorithm::SortPointsByLayer( PointCollection *pointCollection ) {

		int i = 0;
		int j = 0;
		Point *point = 0;

		for( j=1 ; j<pointCollection->size() ; j++ ) {

			i = j-1;
			while( pointCollection->at(j)->GetCluster()->GetPosition().z() > pointCollection->at(i)->GetCluster()->GetPosition().z() ) {
				point = pointCollection->at(i);
				pointCollection->at(i) = pointCollection->at(j);
				pointCollection->at(j) = point;
				i=i-1;
				j=j-1;
				if( i<0 ) break;
			}
		}
	}


	void TrackFinderAlgorithm::DrawEveArrow( double I1 , double J1 , double K1 ,
											  double I2 , double J2 , double K2 ,
											  int color ) {

		if( BaboonMonitoring::IsEnable() && gEve ) {

			unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
			double cellSize0 = calorimeter->GetCellSize0();
			double cellSize1 = calorimeter->GetCellSize1();
			double layerThickness = calorimeter->GetLayerThickness();
			double absorberThickness = calorimeter->GetAbsorberThickness();
			int repeatX = calorimeter->GetRepeatX();
			int repeatY = calorimeter->GetRepeatY();

			double shiftXFactor = cellSize0*repeatX / 2.0;
			double shiftYFactor = cellSize1*repeatY / 2.0;
			double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

			BaboonMonitoring *monitoring = BaboonMonitoring::GetInstance();

			TEveArrow *connectionArrow = new TEveArrow( cellSize0*I2-cellSize0*I1
													  , cellSize1*J2-cellSize1*J1
													  , layerThickness*K2-layerThickness*K1
													  , cellSize0*I1 - shiftXFactor
													  , cellSize1*J1 - shiftYFactor
													  , layerThickness*K1 + shiftZFactor );

			connectionArrow->SetMainColor( color );
			connectionArrow->SetPickable( true );
			connectionArrow->SetTubeR( 0.05 );
			connectionArrow->SetConeR( 0.008 );
			connectionArrow->SetConeL( 0.008 );
			monitoring->AddElement( connectionArrow );
		}

	}


	void TrackFinderAlgorithm::DrawTrackConnectors( PointCollection *trackPoints , int color ) {



		if( BaboonMonitoring::IsEnable() && gEve ) {

			Cluster *currentCluster = 0;
			Cluster *nextCluster = 0;

			for( unsigned int p=0 ; p<trackPoints->size() ; p++ ) {

				// The last cluster is not connected, since it is the last one ...
				if( p == trackPoints->size() - 1 )
					break;

				currentCluster = trackPoints->at( p )->GetCluster();
				nextCluster = trackPoints->at( p + 1 )->GetCluster();

				ThreeVector currentClusterPosition = currentCluster->GetPosition();
				ThreeVector nextClusterPosition = nextCluster->GetPosition();

				this->DrawEveArrow( currentClusterPosition.x() , currentClusterPosition.y() , currentClusterPosition.z() ,
						nextClusterPosition.x() , nextClusterPosition.y() , nextClusterPosition.z() ,
						color );

			}

		}

	}


}  // namespace 

