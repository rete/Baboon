  /// \file ClusteringAlgorithm.cc
/*
 *
 * ClusteringAlgorithm.cc source template generated by fclass
 * Creation date : mar. mai 7 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Algorithm/Calorimetry/ClusteringAlgorithm.hh"

using namespace std;


namespace baboon {



	ClusteringAlgorithm::ClusteringAlgorithm()
		: AbstractAlgorithm("ClusteringAlgorithm") {

		needData = false;
		fClusteringMode = fClustering2D;
		fTaggingMode = fClusterTagMode;
		clusterCollection = 0;
		clusterSizeLowerLimit = 1;
		neighborDistance = 1;
		calorimeter = 0;

	}

	ClusteringAlgorithm::~ClusteringAlgorithm() {

	}


	Return ClusteringAlgorithm::Init() {


		return BABOON_SUCCESS();
	 }

	Return ClusteringAlgorithm::Execute() {


		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		if( caloHitCollection->empty() )
			return BABOON_SUCCESS();

		for( unsigned int i=0 ; i<caloHitCollection->size() ; i++ ) {

			CaloHit *caloHit = caloHitCollection->at(i);
			IntVector ijk = caloHit->GetIJK();

			if( find( treatedHits.begin() , treatedHits.end() , caloHit ) != treatedHits.end() )
				continue;

			treatedHits.push_back( caloHit );

			if ( !CheckTag( caloHitCollection->at( i )->GetTag() ) )
				continue;

			Cluster *cluster = new Cluster();
			cluster->AddCaloHit( caloHit );

			this->FindCluster( caloHit , cluster );

			if( fClusteringMode == fClustering2D ) cluster->SetClusterType( fCluster2D );
			else if( fClusteringMode == fClustering3D ) cluster->SetClusterType( fCluster3D );

			if( cluster->Size() < clusterSizeLowerLimit ) {
				delete cluster;
				continue;
			}
			clusterCollection->push_back( cluster );
		}
		return BABOON_SUCCESS();
	}


	Return ClusteringAlgorithm::End() {

		treatedHits.clear();
		hitTagToCluster.clear();
		hitTagToAvoid.clear();
		neighborDistance = 1;
		clusterSizeLowerLimit = 1;
		calorimeter = 0;
		return BABOON_SUCCESS();
	}

	Return ClusteringAlgorithm::FindCluster( CaloHit *caloHit , Cluster *cluster ) {

		IntVector ijk = caloHit->GetIJK();

		int distance = neighborDistance;

		for( int i=-distance ; i<=distance ; i++ ) {
			for( int j=-distance ; j<=distance ; j++ ) {
				for( int k=-distance ; k<=distance ; k++ ) {

					if( fClusteringMode == fClustering2D )
						if( k != 0 )
							continue;

					if( !calorimeter->IsPadFired( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k ) )
						continue;

					CaloHit *otherHit = calorimeter->GetCaloHitAt( ijk.at(0)+i , ijk.at(1)+j , ijk.at(2)+k );

					if( find( treatedHits.begin() , treatedHits.end() , otherHit ) != treatedHits.end() )
						continue;

					if( cluster->Contains( otherHit ) )
						continue;

					treatedHits.push_back( otherHit );

					if ( !CheckTag( otherHit->GetTag() ) )
						continue;

					cluster->AddCaloHit( otherHit );
					this->FindCluster( otherHit , cluster );
				}
			}
		}
		return BABOON_SUCCESS();
	}

	Return ClusteringAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		BABOON_CHECK_POINTER( clusterCollection );

		for( unsigned int i=0 ; i<hitTagToCluster.size() ; i++ ) {
			if( std::find( hitTagToAvoid.begin() , hitTagToAvoid.end() , hitTagToCluster.at(i) ) != hitTagToAvoid.end() ) {
				return BABOON_ERROR("Tag to be avoided also set to be clustered ... Check your inputs!");
			}
		}

		return BABOON_SUCCESS();
	}


	Return ClusteringAlgorithm::AddHitTagToCluster( const BaseTag &tag ) {

		if( std::find( hitTagToCluster.begin() , hitTagToCluster.end() , tag ) == hitTagToCluster.end() ) {
			hitTagToCluster.push_back( tag );
			return BABOON_SUCCESS();
		}
		return BABOON_ALREADY_PRESENT("Warning : hit tag was already added");
	}


	Return ClusteringAlgorithm::AddHitTagToAvoid( const BaseTag &tag ) {

		if( std::find( hitTagToAvoid.begin() , hitTagToAvoid.end() , tag ) == hitTagToAvoid.end() ) {
			hitTagToAvoid.push_back( tag );
			return BABOON_SUCCESS();
		}
		else return BABOON_ALREADY_PRESENT("Warning : hit tag was already added");
	}


	bool ClusteringAlgorithm::AvoidTag( const BaseTag &tag ) {

		if( std::find( hitTagToAvoid.begin() , hitTagToAvoid.end() , tag ) != hitTagToAvoid.end() ) {
			return true;
		}
		return false;
	}


	bool ClusteringAlgorithm::KeepTag( const BaseTag &tag ) {

		if( std::find( hitTagToCluster.begin() , hitTagToCluster.end() , tag ) != hitTagToCluster.end() ) {
			return true;
		}
		return false;
	}

	bool ClusteringAlgorithm::CheckTag( const BaseTag &tag ) {

		if( fTaggingMode == fAvoidTagMode ) {
			if( hitTagToAvoid.empty() ) return true;
			else return !AvoidTag( tag );
		}
		else if( fTaggingMode == fClusterTagMode ) {
			if( hitTagToCluster.empty() ) return true;
			else return KeepTag( tag );
		}
		else return true;
	}

	Return ClusteringAlgorithm::SetClusterSizeLowerLimit( unsigned int limit ) {

		clusterSizeLowerLimit = limit;
		return BABOON_SUCCESS();
	}

	Return ClusteringAlgorithm::SetNeighborDistance( unsigned int distance ) {

		neighborDistance = distance;
		return BABOON_SUCCESS();
	}

	Return ClusteringAlgorithm::SetClusteringMode( ClusteringMode mode ) {

		fClusteringMode = mode;
		return BABOON_SUCCESS();
	}

	Return ClusteringAlgorithm::SetTaggingMode( TaggingMode mode ) {

		fTaggingMode = mode;
		return BABOON_SUCCESS();
	}

	Return ClusteringAlgorithm::SetCalorimeter( Calorimeter *calo ) {

		BABOON_CHECK_POINTER( calo );

		calorimeter = calo;
		return BABOON_SUCCESS();
	}

}  // namespace 

