  /// \file ConnectorClusteringAlgorithm.cc
/*
 *
 * ConnectorClusteringAlgorithm.cc source template generated by fclass
 * Creation date : jeu. oct. 10 2013
 *
 * This file is part of Baboon libraries.
 * 
 * Baboon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * Baboon is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Baboon.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Rémi Eté
 * @version 1.0.0
 * @copyright Rémi Eté
 *
 *
 */


#include "Algorithm/Calorimetry/ConnectorClusteringAlgorithm.hh"

#include "Utilities/Globals.hh"

using namespace std;

// TODO :
// * Find a way to merge correctly missing cluster that are mainly tracks


namespace baboon {


	ConnectorClusteringAlgorithm::ConnectorClusteringAlgorithm()
		: AbstractAlgorithm("ConnectorClusteringAlgorithm") {

		needData = true;
		calorimeter = 0;
	}

	ConnectorClusteringAlgorithm::~ConnectorClusteringAlgorithm() {

	}


	Return ConnectorClusteringAlgorithm::Init() {

		data.GetValue( "thresholdDistanceXY" , &thresholdDistanceXY );
		data.GetValue( "thresholdDistanceZ" , &thresholdDistanceZ );
		data.GetValue( "drawConnectors" , &drawConnectors );
		data.GetValue( "shouldUseIsolatedHits" , &shouldUseIsolatedHits );

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::Execute() {


		InitializeConnectors();

		IterateAndCleanConnectors();

		CreateClusters();

		for( unsigned int cl=0 ; cl<finalClusters.size() ; cl++ ) {

			CaloHitCollection *clusterHits = finalClusters.at(cl)->GetCaloHitCollection();
			ClusteringManager::GetInstance()->AddCluster( finalClusters.at(cl) );

			for( unsigned int c1=0 ; c1<clusterHits->size() ; c1++ )
				clusterHits->at(c1)->SetColor( cl + 1 );
		}

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::End() {

		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {
			if( connectors.at( co ) != 0 )
				delete connectors.at( co );
		}

		connectors.clear();
		calorimeter = 0;
		finalClusters.clear();
		usedCaloHits.clear();

		return BABOON_SUCCESS();
	}


	void ConnectorClusteringAlgorithm::DrawConnector( Connector< CaloHit, CaloHit> *connector , int color ) {

		if( BaboonMonitoring::IsEnable() && gEve ) {

			CaloHit *caloHit1 = connector->First();
			CaloHit *caloHit2 = connector->Second();
			IntVector ijk1 = caloHit1->GetIJK();
			IntVector ijk2 = caloHit2->GetIJK();

			unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
			double cellSize0 = calorimeter->GetCellSize0();
			double cellSize1 = calorimeter->GetCellSize1();
			double layerThickness = calorimeter->GetLayerThickness();
			double absorberThickness = calorimeter->GetAbsorberThickness();
			int repeatX = calorimeter->GetRepeatX();
			int repeatY = calorimeter->GetRepeatY();

			double shiftXFactor = cellSize0*repeatX / 2.0;
			double shiftYFactor = cellSize1*repeatY / 2.0;
			double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

			BaboonMonitoring *monitoring = BaboonMonitoring::GetInstance();

			TEveArrow *connectionArrow = new TEveArrow( cellSize0*ijk2.at(0)-cellSize0*ijk1.at(0)
													  , cellSize1*ijk2.at(1)-cellSize1*ijk1.at(1)
													  , layerThickness*ijk2.at(2)-layerThickness*ijk1.at(2)
													  , cellSize0*ijk1.at(0) - shiftXFactor
													  , cellSize1*ijk1.at(1) - shiftYFactor
													  , layerThickness*ijk1.at(2) + shiftZFactor );

			connectionArrow->SetMainColor( color );
			connectionArrow->SetPickable( true );
			monitoring->AddElement( connectionArrow );
		}

	}


	void ConnectorClusteringAlgorithm::InitializeConnectors() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return;

		for( unsigned int c1=0 ; c1<caloHitCollection->size() ; c1++ ) {

			CaloHit *caloHit1 = caloHitCollection->at(c1);

			if( caloHit1->GetTag() == IsolatedTag() && !shouldUseIsolatedHits )
				continue;

			int K1 = caloHit1->GetIJK().at(2);
			ThreeVector pos1 = caloHit1->GetPosition();

			for( unsigned int c2=0 ; c2<caloHitCollection->size() ; c2++ ) {

				CaloHit *caloHit2 = caloHitCollection->at(c2);

				if( caloHit2->GetTag() == IsolatedTag() && !shouldUseIsolatedHits )
					continue;

				int K2 = caloHit2->GetIJK().at(2);
				ThreeVector pos2 = caloHit2->GetPosition();
				double xDif = pos1.x() - pos2.x();
				double yDif = pos1.y() - pos2.y();
				double xyDistance = sqrt( xDif*xDif + yDif*yDif );
				double zDistance = fabs( pos1.z() - pos2.z() );

				if( K1 < K2 && xyDistance < thresholdDistanceXY && zDistance < thresholdDistanceZ ) {

					Connector<CaloHit,CaloHit> *connector = new Connector<CaloHit,CaloHit>();
					connector->Connect( caloHit1 , caloHit2 );
					connector->SetWeight( (pos1 - pos2).mag() );
					connectors.push_back( connector );
				}
			}
		}
	}


	void ConnectorClusteringAlgorithm::IterateAndCleanConnectors() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return;

		CaloHitConnectors outputConnectors;

		for( unsigned int c1=0 ; c1<caloHitCollection->size() ; c1++ ) {

			CaloHit *caloHit1 = caloHitCollection->at(c1);

			if( caloHit1->GetTag() == IsolatedTag() && !shouldUseIsolatedHits )
				continue;

			ThreeVector pos1 = caloHit1->GetPosition();
			bool hasBackwardConnection = false;
			bool hasForwardConnection = false;
			ThreeVector meanForwardDirection;
			ThreeVector meanBackwardDirection;
			int nbBackward = 0;
			int nbForward = 0;

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

				if( connectors.at(co)->Second() == caloHit1 ) {

					nbBackward++;
					CaloHit *caloHit2 = connectors.at(co)->First();
					ThreeVector pos2 = caloHit2->GetPosition();
					hasBackwardConnection = true;
					ThreeVector diffPos = pos2 - pos1;
					double connectionFactor = 0.0;

					if( caloHit1->GetTag() == TrackTag()
					 && caloHit2->GetTag() == TrackTag()
					 && this->BelongToSameTrack( caloHit1 , caloHit2 ) )  // TODO forcer la connection pour les traces
						connectionFactor = 10.0;
					else if( caloHit2->GetTag() == IsolatedTag() )
						connectionFactor = 0.2;
					else
						connectionFactor = 1.0;

					meanBackwardDirection += diffPos.unit()*connectionFactor;
				}
			} // connector loop

			if( !hasForwardConnection && !hasBackwardConnection )
				continue;

			if( !hasBackwardConnection )
				continue;

			ThreeVector referenceVector( meanBackwardDirection.unit() );
			Connector<CaloHit, CaloHit> *bestConnector = 0;
			double minAngleDistance = 1000000000;

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

				if( connectors.at(co)->Second() == caloHit1 ) {

					if( bestConnector == 0 ) {
						bestConnector = connectors.at(co);
						continue;
					}
					else {

						CaloHit *caloHit2 = connectors.at(co)->First();
						ThreeVector diffPos = caloHit2->GetPosition() - caloHit1->GetPosition();
						double angleDistance = diffPos.angle( referenceVector )*sqrt( diffPos.mag() ); // TODO ajouter poids relatif entre dist et angle

						if( angleDistance < minAngleDistance ) {

							bestConnector = connectors.at(co);
							minAngleDistance = angleDistance;
						}
					}
				}
			} // connector loop

			// debug check
			assert( bestConnector != 0 );
			outputConnectors.push_back( bestConnector );
		}

		// Remove all the connectors that are not the bests
		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

			if( std::find( outputConnectors.begin() , outputConnectors.end() , connectors.at(co) ) == outputConnectors.end() ) {

				delete connectors.at(co);
				connectors.erase( connectors.begin() + co );
				co --;
			}
		}

		if( drawConnectors ) {
			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {
				this->DrawConnector( connectors.at(co) , kBlack );
			}
		}
		outputConnectors.clear();
	}


	void ConnectorClusteringAlgorithm::CreateClusters() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return;

		std::sort( caloHitCollection->begin() , caloHitCollection->end() , CaloHit::SortByLayer );

		for( unsigned int c1=0 ; c1<caloHitCollection->size() ; c1++ ) {

			CaloHit *caloHit = caloHitCollection->at(c1);

			if( caloHit->GetTag() == IsolatedTag() )
				continue;

			if( std::find( usedCaloHits.begin() , usedCaloHits.end() , caloHit ) != usedCaloHits.end() )
				continue;

			Cluster *cluster = new Cluster();
			cluster->SetClusterType( fCluster3D );
			cluster->AddCaloHit( caloHit );
			usedCaloHits.push_back( caloHit );

			this->RecursiveClustering( caloHit , cluster );

			finalClusters.push_back( cluster );
		}
	}


	void ConnectorClusteringAlgorithm::RecursiveClustering( CaloHit *caloHit , Cluster *cluster ) {

		if( caloHit == 0 || cluster == 0 )
			return;

		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

			if( connectors.at(co)->First() == caloHit ) {

				if( cluster->Contains( connectors.at(co)->Second() ) )
					continue;

				if( std::find( usedCaloHits.begin() , usedCaloHits.end() , connectors.at(co)->Second() ) != usedCaloHits.end() )
					continue;

				cluster->AddCaloHit( connectors.at(co)->Second() );
				usedCaloHits.push_back( connectors.at(co)->Second() );

				this->RecursiveClustering( connectors.at(co)->Second() , cluster );
			}
		}
	}


	bool ConnectorClusteringAlgorithm::BelongToSameTrack( CaloHit *caloHit1 , CaloHit *caloHit2 ) {

		TrackCollection *tracks = TrackManager::GetInstance()->GetTrackCollection();

		if( tracks->empty() )
			return false;

		Track *track1 = 0;

		for( unsigned int tr=0 ; tr<tracks->size() ; tr++ ) {

			if( tracks->at(tr)->Contains( caloHit1 ) ) {
				track1 = tracks->at(tr);
				break;
			}
		}

		if( track1 == 0 )
			return false;

		return track1->Contains( caloHit2 );
	}

}  // namespace 

