  /// \file ConnectorClusteringAlgorithm.cc
/*
 *
 * ConnectorClusteringAlgorithm.cc source template generated by fclass
 * Creation date : jeu. oct. 10 2013
 *
 * This file is part of Baboon libraries.
 * 
 * Baboon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * Baboon is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Baboon.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Rémi Eté
 * @version 1.0.0
 * @copyright Rémi Eté
 *
 *
 */


#include "Algorithm/Calorimetry/ConnectorClusteringAlgorithm.hh"

using namespace std;

namespace baboon {


	ConnectorClusteringAlgorithm::ConnectorClusteringAlgorithm()
		: AbstractAlgorithm("ConnectorClusteringAlgorithm") {

		needData = true;
		calorimeter = 0;
		trackHelpers = new TrackHelperCollection();
	}

	ConnectorClusteringAlgorithm::~ConnectorClusteringAlgorithm() {

		for( unsigned int tr=0 ; tr<trackHelpers->size() ; tr++ ) {
			if( trackHelpers->at( tr ) != 0 )
				delete trackHelpers->at( tr );
		}
		trackHelpers->clear();
		delete trackHelpers;
	}


	Return ConnectorClusteringAlgorithm::Init() {

		data.GetValue( "lookupTransverseDistance" , &lookupTransverseDistance );
		data.GetValue( "lookupLayerDistance" , &lookupLayerDistance );
		data.GetValue( "maxNbOfForwardConnectors" , &maxNbOfForwardConnectors );
		data.GetValue( "trackConnectionConeLength" , &trackConnectionConeLength );
		data.GetValue( "trackConnectionOpeningAngle" , &trackConnectionOpeningAngle );
		data.GetValue( "minimumWeight" , &minimumWeight);

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );
		if( lookupTransverseDistance <= 0 || lookupLayerDistance <= 0 )
			return BABOON_INVALID_PARAMETER( "lookup distance (transverse or layer) should be > 0 !" );
		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::Execute() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();
		unsigned int nbOfLayers = calorimeter->GetNbOfLayers();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return BABOON_SUCCESS();

		TrackCollection *trackCollection = TrackManager::GetInstance()->GetTrackCollection();


		for( unsigned int tr=0 ; tr<trackCollection->size() ; tr++ ) {

			Track *track = trackCollection->at( tr );
			TrackHelper *trackHelper = new TrackHelper();
			trackHelper->track = track;
			this->FillTrackHelper( trackHelper );
			trackHelpers->push_back( trackHelper );
		}

		// Order the calo hits by layer
		// Choose only the one that are not tagged as isolated or track
		for( unsigned int h=0 ; h<caloHitCollection->size() ; h++ ) {

			CaloHit *caloHit = caloHitCollection->at( h );

			if( caloHit->GetTag() == IsolatedTag() || caloHit->GetTag() == TrackTag() )
				continue;

			int layer = caloHit->GetIJK().at(2);

			if( allOrderedPoints[ layer ] == 0 )
				allOrderedPoints[ layer ] = new PointCollection< CaloHit * , CaloHit * >::type();

			Point< CaloHit * , CaloHit *> *caloHitPoint = new Point< CaloHit * , CaloHit *>();
			caloHitPoint->SetObject( caloHit );
			allPoints.push_back( caloHitPoint );
			allOrderedPoints[ layer ]->push_back( caloHitPoint );
		}

		// Connect all the calo hits layer by layer in a given region
		for( unsigned int l=0 ; l<nbOfLayers ; l++ ) {

			this->ConnectLayerCaloHits( l );
		}

		// Iterate on each point and keep only the best connectors
//		for( unsigned int p=0 ; p<allPoints.size() ; p++ ) {
//
//			Point<CaloHit*,CaloHit*> *point = allPoints.at( p );
//			ConnectorCollection<CaloHit*,CaloHit*>::type &connectorCollection = point->GetConnectors();
//
//			this->SortConnectorsByWeight( connectorCollection );
//			int count = 0;
//
//			for( unsigned int c=0 ; c<connectorCollection.size() ; c++ ) {
//
//				if( connectorCollection.at( c )->GetFirst()->GetObject() == point->GetObject() ) {
//
//					if( count >= maxNbOfForwardConnectors ) {
//
//						if( connectorCollection.at( c )->GetWeight() > minimumWeight )
//						connectorCollection.at( c )->SetGood( false );
//					}
//					else
//						count++;
//				}
//			}
//
//
//
//			for( unsigned int c=0 ; c<connectorCollection.size() ; c++ ) {
//
//				if( connectorCollection.at( c )->IsGood() )
//					this->DrawConnector( connectorCollection.at( c ) , kWhite );
//			}
//		}




//		this->ConnectTracksWithClusters();

		// Connect Tracks With Clusters

		ShowerCollection showerCollection;

		for( unsigned int th=0 ; th<trackHelpers->size() ; th++ ) {

			Track *track = trackHelpers->at( th )->track;

			Cone *forwardCone = new Cone( trackHelpers->at( th )->endPosition
										, trackConnectionOpeningAngle
										, trackHelpers->at( th )->forwardThrust
										, trackConnectionConeLength*std::tan(trackConnectionOpeningAngle) );

			trackHelpers->at( th )->forwardConnectedPoints.clear();

			for( unsigned int p=0 ; p<allPoints.size() ; p++ ) {

				CaloHit *caloHit = allPoints.at( p )->GetObject();

				if( forwardCone->Contains( caloHit->GetPosition() ) )
					trackHelpers->at( th )->forwardConnectedPoints.push_back( allPoints.at( p ) );

			}

			if( !trackHelpers->at( th )->forwardConnectedPoints.empty() ) {

				cout << "trackHelper->beginPosition : " << trackHelpers->at( th )->beginPosition << endl;
				cout << "trackHelper->endPosition : " << trackHelpers->at( th )->endPosition << endl;
				cout << "trackHelper->backwardThrust : " << trackHelpers->at( th )->backwardThrust << endl;
				cout << "trackHelper->forwardThrust : " << trackHelpers->at( th )->forwardThrust << endl;
				cout << "trackHelper->forwardConnectedPoints.size() : " << trackHelpers->at( th )->forwardConnectedPoints.size() << endl;
				cout << endl;

				Shower *newShower = new Shower();
//				newShower->AddTrack( trackHelpers->at( th )->track );
				showerCollection.push_back( newShower );



//				this->AgglomerateChargedParticle( trackHelpers->at( th ) );

			}

		}



		ThreeVector v( 2.0 , 1.0 , 0.0 );
		ThreeVector p( 3.5 , 3.0 , 0.0 );
		ThreeVector lookV( 3.0 , 4.0 , 0.0 );

		cout << "Look for value : " << (lookV - p ).mag()  << endl;
		cout << "Test with p.projection(v) : " << endl;
		cout << p.project( v ) << endl;
		cout << "Test with v.projection(p) : " << endl;
		cout << v.project( p ) << endl;
		cout << "Test with p.howNear(v) : " << endl;
		cout << p.howNear( v ) << endl;
		cout << "Test with v.howNear(p) : " << endl;
		cout << v.howNear( p ) << endl;

		// The good one
		cout << "Test with p.per(v) : " << endl;
		cout << p.perp( v ) << endl;

		cout << "Test with v.per(p) : " << endl;
		cout << v.perp( p ) << endl;

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::End() {

		/*
		 * deletion area
		 */

		// all points
		for( unsigned int p=0 ; p<allPoints.size() ; p++ ) {
			if( allPoints.at( p ) != 0 )
				delete allPoints.at( p );
		}
		allPoints.clear();

		// all connectors
		for( unsigned int p=0 ; p<allConnectors.size() ; p++ ) {
			if( allConnectors.at( p ) != 0 )
				delete allConnectors.at( p );
		}
		allConnectors.clear();

		// ordered point collections
		OrderedPointCollection< CaloHit * , CaloHit * >::type::iterator it;
		for( it=allOrderedPoints.begin() ; it!=allOrderedPoints.end() ; it++ ) {
			if( it->second != 0 ) {
				it->second->clear();
				delete it->second;
			}
		}
		allOrderedPoints.clear();

		calorimeter = 0;

		for( unsigned int tr=0 ; tr<trackHelpers->size() ; tr++ ) {
			if( trackHelpers->at( tr ) != 0 )
				delete trackHelpers->at( tr );
		}
		trackHelpers->clear();

		return BABOON_SUCCESS();
	}


	void ConnectorClusteringAlgorithm::FillTrackHelper( TrackHelper *trackHelper ) {

		if( trackHelper == 0 ) {
			return;
		}

		Track *track = trackHelper->track;

		track->SortHits();
		CaloHitCollection *trackHits = track->GetCaloHitCollection();
		int lastTrackLayer = track->GetCaloHitCollection()->at( track->Size() - 1 )->GetIJK().at(2);
		int firstTrackLayer = track->GetCaloHitCollection()->at( 0 )->GetIJK().at(2);

		ClusterCollection trackClusters;
		Cluster *currentCluster = new Cluster();

		for( unsigned int h=0 ; h<trackHits->size() ; h++ ) {

			CaloHit *caloHit = trackHits->at( h );
			if( h == trackHits->size() - 1 ) {
				currentCluster->AddCaloHit( caloHit );
				trackClusters.push_back( currentCluster );
				break;
			}

			CaloHit *hit = trackHits->at( h );
			CaloHit *nextHit = trackHits->at( h+1 );

			if( hit->GetIJK().at(2) == nextHit->GetIJK().at(2) ) {
				currentCluster->AddCaloHit( hit );
				continue;
			}
			else {
				currentCluster->AddCaloHit( hit );
				trackClusters.push_back( currentCluster );
				currentCluster = new Cluster();
			}
		}

		currentCluster = 0;

		for( unsigned int cl=0 ; cl<trackClusters.size() ; cl++ ) {

			if( cl == 0 )
				trackHelper->beginPosition = trackClusters.at( cl )->GetPosition( fComputePosition );

			if( cl == trackClusters.size() - 1 ) {
				trackHelper->endPosition = trackClusters.at( cl )->GetPosition( fComputePosition );
				break;
			}

			Cluster *cluster = trackClusters.at( cl );
			Cluster *nextCluster = trackClusters.at( cl+1 );
			ThreeVector difference = nextCluster->GetPosition( fComputePosition ) - cluster->GetPosition( fComputePosition );

			if( difference.z() < 0 )
				difference = -difference;

			// for the track beginning
			if( cl < 4 ) {
				trackHelper->backwardThrust += difference;

			}
			// for the track end
			if( cl > trackClusters.size() - 4 ) {
				trackHelper->forwardThrust += difference;
			}
		}

		if( trackHelper->backwardThrust != ThreeVector() )
			trackHelper->backwardThrust.setMag( 1.f );
		if( trackHelper->forwardThrust != ThreeVector() )
			trackHelper->forwardThrust.setMag( 1.f );

		if( trackHelper->backwardThrust.z() > 0 )
			trackHelper->backwardThrust = -trackHelper->backwardThrust;
		if( trackHelper->forwardThrust.z() < 0 )
			trackHelper->forwardThrust = -trackHelper->forwardThrust;

		TrackExtremities extremities = track->GetExtremities();
		CaloHit *first = extremities.first;
		CaloHit *last = extremities.second;

		ThreeVector direction = first->GetPosition() - last->GetPosition();
		if( direction.z() < 0.f )
			direction = -direction;

		if( direction.theta() < 0.3 ) {
			if( first->GetPosition().z() < -600.f && last->GetPosition().z() < -600.f ) {
				trackHelper->isPrimaryTrack = true;
			}
		}


		for( unsigned int cl=0 ; cl<trackClusters.size() ; cl++ ) {
			if( trackClusters.at( cl ) != 0 )
				delete trackClusters.at( cl );
		}
		trackClusters.clear();

	}



	void ConnectorClusteringAlgorithm::ConnectLayerCaloHits( int layer ) {


		// tester si les deux collections ne sont pas vides !!!!!

		PointCollection< CaloHit * , CaloHit * >::type *pointCollection1 = allOrderedPoints[ layer ];

		// if there is not calo hits in the layer, return ...
		if( pointCollection1 == 0 )
			return;

		for( unsigned int p1=0 ; p1<pointCollection1->size() ; p1++ ) {

			Point< CaloHit * , CaloHit * > *point1 = pointCollection1->at( p1 );
			CaloHit *caloHit1 = point1->GetObject();

			for( unsigned int l=layer+1 ; l<=layer+lookupLayerDistance ; l++ ) {

				PointCollection< CaloHit * , CaloHit * >::type *pointCollection2 = allOrderedPoints[ l ];

				// if no calo hits in the layer continue;
				if( pointCollection2 == 0 )
					continue;

				for( unsigned int p2=0 ; p2<pointCollection2->size() ; p2++ ) {

					Point< CaloHit * , CaloHit * > *point2 = pointCollection2->at( p2 );
					CaloHit *caloHit2 = point2->GetObject();

					if( abs( caloHit2->GetPosition().x() - caloHit1->GetPosition().x() ) > lookupTransverseDistance
					 || abs( caloHit2->GetPosition().y() - caloHit1->GetPosition().y() ) > lookupTransverseDistance )
						continue;

					// Weight the link according to the distance and the difference of density
					double distance = ( caloHit2->GetPosition() - caloHit1->GetPosition() ).mag();
					// delta density normalized to 1
					double deltaDensity = abs( caloHit2->GetDensity() - caloHit1->GetDensity() ) / 3.0;
					double coreFactor = 1.0;

					if( caloHit1->GetTag() == CoreTag() && caloHit2->GetTag() == CoreTag() )
						coreFactor = 10.0;
					else if( caloHit1->GetTag() == CoreTag() && caloHit1->GetTag() != CoreTag() )
						coreFactor = 5.0;
					else if( caloHit1->GetTag() != CoreTag() && caloHit1->GetTag() != CoreTag() )
						coreFactor = 5.0;
					else
						coreFactor = 1.0;

					double weight = 0.f;

					if( deltaDensity != 0 )
						weight =  coreFactor / ( distance*deltaDensity );
					else
						weight =  coreFactor / ( distance );
//					cout << "weight : " << weight << endl;

					Connector< CaloHit * , CaloHit * > *connector = new Connector< CaloHit * , CaloHit * >();
					connector->Connect( point1 , point2    // the connected points
										, weight ); // the weight
					point1->AddConnector( connector );
					point2->AddConnector( connector );

					// for memory management...
					allConnectors.push_back( connector );
//					this->DrawConnector( connector , kWhite );
				}
			}


		}

	}



	void ConnectorClusteringAlgorithm::DrawConnector( Connector< CaloHit * , CaloHit * > *connector , int color ) {

		if( BaboonMonitoring::IsEnable() && gEve ) {

			CaloHit *caloHit1 = connector->GetFirst()->GetObject();
			CaloHit *caloHit2 = connector->GetSecond()->GetObject();
			IntVector ijk1 = caloHit1->GetIJK();
			IntVector ijk2 = caloHit2->GetIJK();

			unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
			double cellSize0 = calorimeter->GetCellSize0();
			double cellSize1 = calorimeter->GetCellSize1();
			double layerThickness = calorimeter->GetLayerThickness();
			double absorberThickness = calorimeter->GetAbsorberThickness();
			int repeatX = calorimeter->GetRepeatX();
			int repeatY = calorimeter->GetRepeatY();

			double shiftXFactor = cellSize0*repeatX / 2.0;
			double shiftYFactor = cellSize1*repeatY / 2.0;
			double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

			BaboonMonitoring *monitoring = BaboonMonitoring::GetInstance();

			TEveArrow *connectionArrow = new TEveArrow( cellSize0*ijk2.at(0)-cellSize0*ijk1.at(0)
													  , cellSize1*ijk2.at(1)-cellSize1*ijk1.at(1)
													  , layerThickness*ijk2.at(2)-layerThickness*ijk1.at(2)
													  , cellSize0*ijk1.at(0) - shiftXFactor
													  , cellSize1*ijk1.at(1) - shiftYFactor
													  , layerThickness*ijk1.at(2) + shiftZFactor );

			connectionArrow->SetMainColor( color );
			connectionArrow->SetPickable( true );
//			connectionArrow->SetTubeR( 0.05 );
//			connectionArrow->SetConeR( 0.008 );
//			connectionArrow->SetConeL( 0.008 );
			monitoring->AddElement( connectionArrow );
		}

	}



	void ConnectorClusteringAlgorithm::SortConnectorsByWeight( ConnectorCollection< CaloHit * , CaloHit * >::type &connectors ) {

		int i = 0;
		int j = 0;
		Connector< CaloHit * , CaloHit * > *connector = 0;

		for( j=1 ; j<connectors.size() ; j++ ) {

			i = j-1;
			while( connectors.at(j)->GetWeight() > connectors.at(i)->GetWeight() ) {
				connector = connectors.at(i);
				connectors.at(i) = connectors.at(j);
				connectors.at(j) = connector;
				i=i-1;
				j=j-1;
				if( i<0 ) break;
			}
		}
	}

	void ConnectorClusteringAlgorithm::ConnectTracksWithClusters() {

		for( unsigned int th=0 ; th<trackHelpers->size() ; th++ ) {

			Track *track = trackHelpers->at( th )->track;

			Cone *forwardCone = new Cone( trackHelpers->at( th )->endPosition
										, trackConnectionOpeningAngle
										, trackHelpers->at( th )->forwardThrust
										, trackConnectionConeLength*std::tan(trackConnectionOpeningAngle) );

			trackHelpers->at( th )->forwardConnectedPoints.clear();

			for( unsigned int p=0 ; p<allPoints.size() ; p++ ) {

				CaloHit *caloHit = allPoints.at( p )->GetObject();

				if( forwardCone->Contains( caloHit->GetPosition() ) )
					trackHelpers->at( th )->forwardConnectedPoints.push_back( allPoints.at( p ) );

			}


//			cout << "trackHelper->beginPosition : " << trackHelpers->at( th )->beginPosition << endl;
//			cout << "trackHelper->endPosition : " << trackHelpers->at( th )->endPosition << endl;
//			cout << "trackHelper->backwardThrust : " << trackHelpers->at( th )->backwardThrust << endl;
//			cout << "trackHelper->forwardThrust : " << trackHelpers->at( th )->forwardThrust << endl;
//			cout << "trackHelper->forwardConnectedPoints.size() : " << trackHelpers->at( th )->forwardConnectedPoints.size() << endl;
//			cout << endl;

			if( !trackHelpers->at( th )->forwardConnectedPoints.empty() ) {

				cout << "trackHelper->beginPosition : " << trackHelpers->at( th )->beginPosition << endl;
				cout << "trackHelper->endPosition : " << trackHelpers->at( th )->endPosition << endl;
				cout << "trackHelper->backwardThrust : " << trackHelpers->at( th )->backwardThrust << endl;
				cout << "trackHelper->forwardThrust : " << trackHelpers->at( th )->forwardThrust << endl;
				cout << "trackHelper->forwardConnectedPoints.size() : " << trackHelpers->at( th )->forwardConnectedPoints.size() << endl;
				cout << endl;

				this->AgglomerateChargedParticle( trackHelpers->at( th ) );

			}

		}

	}

	void ConnectorClusteringAlgorithm::AgglomerateChargedParticle( TrackHelper *trackHelper ) {

		// TO DO
		// Trouver une fonction de poids pour peser les connections entre hits et decider combien en garder
	}

}  // namespace 

