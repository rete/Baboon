  /// \file ConnectorClusteringAlgorithm.cc
/*
 *
 * ConnectorClusteringAlgorithm.cc source template generated by fclass
 * Creation date : jeu. oct. 10 2013
 *
 * This file is part of Baboon libraries.
 * 
 * Baboon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * Baboon is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Baboon.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Rémi Eté
 * @version 1.0.0
 * @copyright Rémi Eté
 *
 *
 */


#include "Algorithm/Calorimetry/ConnectorClusteringAlgorithm.hh"

#include "Utilities/Globals.hh"

using namespace std;

// TODO :
// * Find a way to merge correctly missing cluster that are mainly tracks


namespace baboon {


	ConnectorClusteringAlgorithm::ConnectorClusteringAlgorithm()
		: AbstractAlgorithm("ConnectorClusteringAlgorithm") {

		needData = true;
		calorimeter = 0;
	}

	ConnectorClusteringAlgorithm::~ConnectorClusteringAlgorithm() {

	}


	Return ConnectorClusteringAlgorithm::Init() {

		data.GetValue( "thresholdDistanceXY" , &thresholdDistanceXY );
		data.GetValue( "thresholdDistanceZ" , &thresholdDistanceZ );
		data.GetValue( "minimumClusterSizeMerging" , &minimumClusterSizeMerging );

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::Execute() {


		InitializeConnectors();

		IterateAndCleanConnectors();

		CreateClusters();

		ClusterMerging();

//		IsolatedHitMerging();

//		cout << "finalClusters.size() : " << finalClusters.size() << endl;

		// for monitoring
		for( unsigned int cl=0 ; cl<finalClusters.size() ; cl++ ) {

			CaloHitCollection *clusterHits = finalClusters.at(cl)->GetCaloHitCollection();

			ClusteringManager::GetInstance()->AddCluster( finalClusters.at(cl) );

			for( unsigned int c1=0 ; c1<clusterHits->size() ; c1++ ) {
				clusterHits->at(c1)->SetColor( cl + 1 );
			}
		}

		return BABOON_SUCCESS();
	}


	Return ConnectorClusteringAlgorithm::End() {

		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {
			if( connectors.at( co ) != 0 )
				delete connectors.at( co );
		}

		connectors.clear();
		calorimeter = 0;
		finalClusters.clear();
		usedCaloHits.clear();

		return BABOON_SUCCESS();
	}


	void ConnectorClusteringAlgorithm::DrawConnector( Connector< CaloHit, CaloHit> *connector , int color ) {

		if( BaboonMonitoring::IsEnable() && gEve ) {

			CaloHit *caloHit1 = connector->First();
			CaloHit *caloHit2 = connector->Second();
			IntVector ijk1 = caloHit1->GetIJK();
			IntVector ijk2 = caloHit2->GetIJK();

			unsigned int nbOfLayers = calorimeter->GetNbOfLayers();
			double cellSize0 = calorimeter->GetCellSize0();
			double cellSize1 = calorimeter->GetCellSize1();
			double layerThickness = calorimeter->GetLayerThickness();
			double absorberThickness = calorimeter->GetAbsorberThickness();
			int repeatX = calorimeter->GetRepeatX();
			int repeatY = calorimeter->GetRepeatY();

			double shiftXFactor = cellSize0*repeatX / 2.0;
			double shiftYFactor = cellSize1*repeatY / 2.0;
			double shiftZFactor = absorberThickness + ( layerThickness - absorberThickness ) / 2.0 ;

			BaboonMonitoring *monitoring = BaboonMonitoring::GetInstance();

			TEveArrow *connectionArrow = new TEveArrow( cellSize0*ijk2.at(0)-cellSize0*ijk1.at(0)
													  , cellSize1*ijk2.at(1)-cellSize1*ijk1.at(1)
													  , layerThickness*ijk2.at(2)-layerThickness*ijk1.at(2)
													  , cellSize0*ijk1.at(0) - shiftXFactor
													  , cellSize1*ijk1.at(1) - shiftYFactor
													  , layerThickness*ijk1.at(2) + shiftZFactor );

			connectionArrow->SetMainColor( color );
			connectionArrow->SetPickable( true );
			monitoring->AddElement( connectionArrow );
		}

	}


	void ConnectorClusteringAlgorithm::InitializeConnectors() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return;

		for( unsigned int c1=0 ; c1<caloHitCollection->size() ; c1++ ) {

			CaloHit *caloHit1 = caloHitCollection->at(c1);

			if( caloHit1->GetTag() == IsolatedTag() )
				continue;

			int K1 = caloHit1->GetIJK().at(2);
			ThreeVector pos1 = caloHit1->GetPosition();

			for( unsigned int c2=0 ; c2<caloHitCollection->size() ; c2++ ) {

				CaloHit *caloHit2 = caloHitCollection->at(c2);

				if( caloHit2->GetTag() == IsolatedTag() )
					continue;

				int K2 = caloHit2->GetIJK().at(2);
				ThreeVector pos2 = caloHit2->GetPosition();
				double xDif = pos1.x() - pos2.x();
				double yDif = pos1.y() - pos2.y();
				double xyDistance = sqrt( xDif*xDif + yDif*yDif );
				double zDistance = fabs( pos1.z() - pos2.z() );

				if( K1 < K2 && xyDistance < thresholdDistanceXY && zDistance < thresholdDistanceZ ) {

					Connector<CaloHit,CaloHit> *connector = new Connector<CaloHit,CaloHit>();
					connector->Connect( caloHit1 , caloHit2 );
					connector->SetWeight( (pos1 - pos2).mag() );
					connectors.push_back( connector );
				}
			}
		}
	}


	void ConnectorClusteringAlgorithm::IterateAndCleanConnectors() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return;

		CaloHitConnectors outputConnectors;

		for( unsigned int c1=0 ; c1<caloHitCollection->size() ; c1++ ) {

			CaloHit *caloHit1 = caloHitCollection->at(c1);

			if( caloHit1->GetTag() == IsolatedTag() )
				continue;

			ThreeVector pos1 = caloHit1->GetPosition();
			bool hasBackwardConnection = false;
			bool hasForwardConnection = false;
			ThreeVector meanForwardDirection;
			ThreeVector meanBackwardDirection;
			int nbBackward = 0;
			int nbForward = 0;

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

				if( connectors.at(co)->First() == caloHit1 ) {

					nbForward++;
					CaloHit *caloHit2 = connectors.at(co)->Second();
					ThreeVector pos2 = caloHit2->GetPosition();
					hasForwardConnection = true;
					ThreeVector diffPos = pos2 - pos1;
					meanForwardDirection += diffPos.unit();
//					meanForwardDirection += diffPos.unit()*static_cast<int>( caloHit2->GetThreshold() );
//					meanForwardDirection += diffPos.unit()*caloHit2->GetDensity();
				}
				else if( connectors.at(co)->Second() == caloHit1 ) {

					nbBackward++;
					CaloHit *caloHit2 = connectors.at(co)->First();
					ThreeVector pos2 = caloHit2->GetPosition();
					hasBackwardConnection = true;
					ThreeVector diffPos = pos2 - pos1;
					meanBackwardDirection += diffPos.unit();
//					meanBackwardDirection += diffPos.unit()*static_cast<int>( caloHit2->GetThreshold() );
//					meanBackwardDirection += diffPos.unit()*caloHit2->GetDensity();
				}
			} // connector loop

			if( !hasForwardConnection && !hasBackwardConnection )
				continue;

			if( !hasBackwardConnection )
				continue;

			ThreeVector referenceVector;

			if( !hasForwardConnection )
				referenceVector = meanBackwardDirection.unit();

			Connector<CaloHit, CaloHit> *bestConnector = 0;
			double minAngleDistance = 1000000000;

			for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

				if( connectors.at(co)->Second() == caloHit1 ) {

					if( bestConnector == 0 ) {
						bestConnector = connectors.at(co);
						continue;
					}
					else {

						CaloHit *caloHit2 = connectors.at(co)->First();
						ThreeVector diffPos = caloHit2->GetPosition() - caloHit1->GetPosition();
						double angleDistance = diffPos.angle( referenceVector )*sqrt( diffPos.mag() );

						if( angleDistance < minAngleDistance ) {

							bestConnector = connectors.at(co);
							minAngleDistance = angleDistance;
						}
					}
				}
			} // connector loop

			// debug check
			assert( bestConnector != 0 );

			outputConnectors.push_back( bestConnector );

		}

		// Remove all the connectors that are not the bests
		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {


			if( std::find( outputConnectors.begin() , outputConnectors.end() , connectors.at(co) ) == outputConnectors.end() ) {

				delete connectors.at(co);
				connectors.erase( connectors.begin() + co );
				co --;
			}
		}

		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {
			this->DrawConnector( connectors.at(co) , kBlack );
		}


		outputConnectors.clear();
	}


	void ConnectorClusteringAlgorithm::CreateClusters() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		// nothing to do if no calo hits
		if( caloHitCollection->empty() )
			return;

		std::sort( caloHitCollection->begin() , caloHitCollection->end() , ConnectorClusteringAlgorithm::SortByLayer );

		for( unsigned int c1=0 ; c1<caloHitCollection->size() ; c1++ ) {

			CaloHit *caloHit = caloHitCollection->at(c1);

			if( caloHit->GetTag() == IsolatedTag() )
				continue;

			if( std::find( usedCaloHits.begin() , usedCaloHits.end() , caloHit ) != usedCaloHits.end() )
				continue;

			Cluster *cluster = new Cluster();
			cluster->SetClusterType( fCluster3D );
			cluster->AddCaloHit( caloHit );
			usedCaloHits.push_back( caloHit );

			this->RecursiveClustering( caloHit , cluster );

			finalClusters.push_back( cluster );
		}
	}


	void ConnectorClusteringAlgorithm::ClusterMerging() {

		// here a cluster merging is done for each clusters that have the first calo hit
		// belonging to the same 2D cluster

		ClusterCollection *clusters2D = ClusteringManager::GetInstance()->GetCluster2D();

		if( clusters2D->empty() )
			return;


		for( unsigned int cl=0 ; cl<finalClusters.size() ; cl++ ) {

			Cluster *cluster = finalClusters.at(cl);
			CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();
			std::sort( clusterHits->begin() , clusterHits->end() , ConnectorClusteringAlgorithm::SortByLayer );
		}

		for( unsigned int cl=0 ; cl<finalClusters.size() ; cl++ ) {

			Cluster *cluster = finalClusters.at(cl);
			CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();

			if( cluster->Size() == 0 )
				continue;

			CaloHit *firstCaloHitInCluster = clusterHits->at(0);

			for( unsigned int cl2=cl ; cl2<finalClusters.size() ; cl2++ ) {

				if( cl == cl2 )
					continue;

				Cluster *cluster2 = finalClusters.at(cl2);

				if( cluster2->Size() == 0 )
					continue;

				CaloHitCollection *clusterHits2 = cluster2->GetCaloHitCollection();

				CaloHit *firstCaloHitInCluster2 = clusterHits2->at(0);
				Cluster *cluster2DOfFirst2 = 0;

				for( unsigned int cl2D=0 ; cl2D<clusters2D->size() ; cl2D++ ) {

					if( clusters2D->at(cl2D)->Contains( firstCaloHitInCluster2 ) ) {
						cluster2DOfFirst2 = clusters2D->at(cl2D);
						break;
					}
				}

				if( cluster2DOfFirst2 == 0 )
					continue;

				// if the two calo hits belongs to the same 2D cluster, set them to be merged
				if( cluster2DOfFirst2->Contains( firstCaloHitInCluster ) ) {

					for( unsigned int clID=0 ; clID<cluster2->Size() ; clID++ )
						cluster->AddCaloHit( cluster2->GetCaloHitCollection()->at(clID) );

					cluster2->Clear();
				}
			}
		}

		for( unsigned int cl=0 ; cl<finalClusters.size() ; cl++ ) {

			if( finalClusters.at(cl)->Size() == 0 ) {

				delete finalClusters.at(cl);
				finalClusters.erase( finalClusters.begin() + cl );
			}
		}


		std::map<Cluster*,Cluster*> smallToBigClustersToMerge;

		for( unsigned int cl=0 ; cl<finalClusters.size() ; cl++ ) {

			if( finalClusters.at(cl)->Size() > minimumClusterSizeMerging )
				continue;

			Cluster *smallCluster = finalClusters.at(cl);

			ThreeVector clusterPosition = smallCluster->GetPosition( fComputePosition );
			double minimumDistance = 100000000.0;
			Cluster *closestCluster = 0;

			for( unsigned int cl2=0 ; cl2<finalClusters.size() ; cl2++ ) {

				if( finalClusters.at(cl2)->Size() <= minimumClusterSizeMerging )
					continue;

				Cluster *cluster2 = finalClusters.at(cl2);

				if( closestCluster == 0 ) {

					minimumDistance = DistanceToCluster( clusterPosition , cluster2 );
					closestCluster = cluster2;
					continue;
				}

				double distance = DistanceToCluster( clusterPosition , cluster2 );

				if( distance < minimumDistance ) {

					minimumDistance = distance;
					closestCluster = cluster2;
				}
			}

			smallToBigClustersToMerge[ smallCluster ] = closestCluster;
		}

		for( std::map<Cluster*,Cluster*>::iterator it=smallToBigClustersToMerge.begin() ;
			it!=smallToBigClustersToMerge.end() ; it++ ) {

			if( it->second == 0 || it->first == 0 )
				continue;

			CaloHitCollection *smallClusterHits = it->first->GetCaloHitCollection();

			for( unsigned int h1=0 ; h1<smallClusterHits->size() ; h1++ )
				it->second->AddCaloHit( smallClusterHits->at(h1) );

			std::vector<Cluster*>::iterator clIt = std::find( finalClusters.begin() , finalClusters.end() , it->first );
			delete (*clIt);
			finalClusters.erase( clIt );
		}
		smallToBigClustersToMerge.clear();
	}


	void ConnectorClusteringAlgorithm::RecursiveClustering( CaloHit *caloHit , Cluster *cluster ) {

		if( caloHit == 0 || cluster == 0 )
			return;

		for( unsigned int co=0 ; co<connectors.size() ; co++ ) {

			if( connectors.at(co)->First() == caloHit ) {

				if( cluster->Contains( connectors.at(co)->Second() ) )
					continue;

				if( std::find( usedCaloHits.begin() , usedCaloHits.end() , connectors.at(co)->Second() ) != usedCaloHits.end() )
					continue;

				cluster->AddCaloHit( connectors.at(co)->Second() );
				usedCaloHits.push_back( connectors.at(co)->Second() );

				this->RecursiveClustering( connectors.at(co)->Second() , cluster );
			}
		}
	}


	bool ConnectorClusteringAlgorithm::SortByLayer( CaloHit *caloHit1 , CaloHit *caloHit2 ) {

		if( caloHit2->GetIJK().at(2) > caloHit1->GetIJK().at(2) )
			return true;
		else return false;
	}


	double ConnectorClusteringAlgorithm::DistanceToCluster( const ThreeVector &pos , Cluster *cluster ) {

		if( cluster == 0 )
			return 0.0;

		CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();

		double distanceMinimum = 10000000.0;

		for( unsigned int i=0 ; i<clusterHits->size() ; i++ ) {

			double distance = (pos - clusterHits->at(i)->GetPosition() ).mag();

			if( distance < distanceMinimum )
				distanceMinimum = distance;

		}

		return distanceMinimum;
	}

}  // namespace 

