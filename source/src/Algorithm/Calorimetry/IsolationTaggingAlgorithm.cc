  /// \file IsolationTaggingAlgorithm.cc
/*
 *
 * IsolationTaggingAlgorithm.cc source template generated by fclass
 * Creation date : lun. avr. 22 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */




#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"



using namespace std;



namespace baboon {


	IsolationTaggingAlgorithm::IsolationTaggingAlgorithm()
		: AbstractAlgorithm("IsolationTaggingAlgorithm") {
		needData = false;
		calorimeter = 0;

		// default values
		distance = 1;
		concentrationLimit = 0.2;
	}


	IsolationTaggingAlgorithm::~IsolationTaggingAlgorithm() {

	}


	Return IsolationTaggingAlgorithm::Init() {

		data.GetValue("distance",&distance);
		data.GetValue("concentrationLimit",&concentrationLimit);
		data.GetValue("maximumClusterSize" , &maximumClusterSize );

		isolationWeights.clear();

		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::Execute() {

		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();
		ClusterCollection *clusters2D = ClusteringManager::GetInstance()->GetCluster2D();

		if( clusters2D->empty() )
			return BABOON_SUCCESS();

		for( unsigned int cl=0 ; cl<clusters2D->size() ; cl++ ) {

			Cluster *cluster = clusters2D->at(cl);

			if( cluster->Size() > maximumClusterSize )
				continue;

			CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();
			double densitySum = 0.0;

			for( unsigned int h=0 ; h<clusterHits->size() ; h++ ) {

				densitySum += clusterHits->at(h)->GetDensity();
			}

			densitySum /= clusterHits->size();

			if( densitySum < concentrationLimit )
				SetClusterHitsTagToIsolated( cluster );

		}

//		unsigned int hitID = 0;
//		unsigned int size = caloHitCollection->size();
//
//		for( hitID=0 ; hitID<size ; hitID++ ) {
//
//			CaloHit *caloHit = caloHitCollection->at(hitID);
//
//			if( caloHit->GetTag() == TrackTag() )
//				continue;
//
//			IntVector ijk1 = caloHit->GetIJK();
//
//			int count = 0;
//			int volume = 0;
//
//			for( int i=-distance ; i<=distance ; i++ ) {
//				for( int j=-distance ; j<=distance ; j++ ) {
//					for( int k=-distance ; k<=distance ; k++ ) {
//
//						volume++;
//
//						if( !calorimeter->IsPadFired( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k ) )
//							continue;
//
//						CaloHit *caloHit2 = calorimeter->GetCaloHitAt( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k );
//
//						if( caloHit2->GetTag() == TrackTag() )
//							continue;
//
//						int factor = 1;
//						factor *= caloHit2->GetThreshold();
//						count += factor;
//					}
//				}
//			}
//
////			caloHit->SetDensity( double(count) / volume );
//
////			isolationWeights.push_back( caloHit->GetDensity() );
////			cout << "density : " << double(count) / volume << endl;
////			if( double(count) / volume < concentrationLimit ) {
//			if( caloHit->GetDensity() < concentrationLimit
//			 && caloHit->GetTag() != TrackTag()
//			 && count/volume < concentrationLimit2 )
//				caloHit->SetTag( IsolatedTag() );
////			}
//		}
		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::End() {

		calorimeter = 0;
		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::SetCalorimeter( Calorimeter *calo ) {

		calorimeter = calo;
		return BABOON_SUCCESS();
	}



	void IsolationTaggingAlgorithm::SetClusterHitsTagToIsolated( Cluster *cluster ) {

		CaloHitCollection *clusterHits = cluster->GetCaloHitCollection();

		for( unsigned int h=0 ; h<clusterHits->size() ; h++ ) {
			if( clusterHits->at(h)->GetTag() != TrackTag() )
				clusterHits->at(h)->SetTag( IsolatedTag() );
		}
	}



}  // namespace 

