  /// \file IsolationTaggingAlgorithm.cc
/*
 *
 * IsolationTaggingAlgorithm.cc source template generated by fclass
 * Creation date : lun. avr. 22 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */




#include "Algorithm/Calorimetry/IsolationTaggingAlgorithm.hh"



using namespace std;



namespace baboon {


	IsolationTaggingAlgorithm::IsolationTaggingAlgorithm()
		: AbstractAlgorithm("IsolationTaggingAlgorithm") {
		needData = false;
		calorimeter = 0;

		// default values
		distance = 1;
		concentrationLimit = 0.2;
	}


	IsolationTaggingAlgorithm::~IsolationTaggingAlgorithm() {

	}


	Return IsolationTaggingAlgorithm::Init() {

		data.GetValue("distance",&distance);
		data.GetValue("concentrationLimit",&concentrationLimit);

		isolationWeights.clear();

		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::CheckConsistency() {

		BABOON_CHECK_POINTER( calorimeter );

		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::Execute() {

//		HitManager *hitManager = HitManager::GetInstance();
		CaloHitCollection *caloHitCollection = calorimeter->GetCaloHitCollection();

		unsigned int hitID = 0;
		unsigned int size = caloHitCollection->size();

		for( hitID=0 ; hitID<size ; hitID++ ) {

			CaloHit *caloHit = caloHitCollection->at(hitID);
			IntVector ijk1 = caloHit->GetIJK();

			int count = 0;
			int volume = 0;

			for( int i=-distance ; i<=distance ; i++ ) {
				for( int j=-distance ; j<=distance ; j++ ) {
					for( int k=-distance ; k<=distance ; k++ ) {

						volume++;

						if( !calorimeter->IsPadFired( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k ) )
							continue;

						CaloHit *caloHit2 = calorimeter->GetCaloHitAt( ijk1.at(0)+i , ijk1.at(1)+j , ijk1.at(2)+k );
						int factor = 1;
						factor *= caloHit2->GetThreshold();
						count += factor;
					}
				}
			}

			caloHit->SetDensity( double(count) / volume );

			isolationWeights.push_back( double(count) / volume );
//			cout << "density : " << double(count) / volume << endl;
			if( double(count) / volume < concentrationLimit ) {
				caloHit->SetTag( IsolatedTag() );
			}
		}
		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::End() {

		calorimeter = 0;
		return BABOON_SUCCESS();
	}

	Return IsolationTaggingAlgorithm::SetCalorimeter( Calorimeter *calo ) {

		calorimeter = calo;
		return BABOON_SUCCESS();
	}



}  // namespace 

