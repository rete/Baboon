/*
 *
 * HoughTransformAlgorithm.cc cpp file template generated by fclass
 * Creation date : Thu Mar 14 21:55:13 2013
 * Copyright (c) CNRS / IPNL
 * All Right Reserved.
 *
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * Written by : R. EtÃ©
 */


#include "Algorithm/Tracking/HoughTransformAlgorithm.hh"


using namespace std;



namespace sdhcal {


	HoughTransformAlgorithm::HoughTransformAlgorithm()
		: AbstractAlgorithm("HoughTransformAlgorithm") {

		thetaMax = 100;
		rMax = 140;
		houghSpaceX = NULL;
		houghSpaceY = NULL;
		trackSegmentCollection = new TrackSegmentCollection();
		needData = true;
		needParams = true;

	}

	HoughTransformAlgorithm::~HoughTransformAlgorithm() {

		this->DeleteHoughSpace();
		delete trackSegmentCollection;
	}


	void HoughTransformAlgorithm::Init() {

		data.GetValue("thetaMax",&thetaMax);
		data.GetValue("rMax",&rMax);
		data.GetValue("clusterSizeLimit",&clusterSizeLimit);
		data.GetValue("minimumBinning",&minimumBinning);
		data.GetValue("deltaPosMax",&deltaPosMax);
		data.GetValue("trackSegmentMinimumSize",&trackSegmentMinimumSize);
		data.GetValue("maximumDistanceBetweenHitsInPlane",&maximumDistanceBetweenHitsInPlane);
		data.GetValue("maximumDistanceBetweenHitsForLayers",&maximumDistanceBetweenHitsForLayers);

		hitCollection = HitManager::GetInstance()->GetHitCollection();

		this->DeleteHoughSpace();
		this->AllocateHoughSpace();



		if(trackSegmentCollection->size() != 0) {
			for(unsigned int i=0 ; i<trackSegmentCollection->size() ; i++) {
				if(trackSegmentCollection->at(i) != NULL)
					delete trackSegmentCollection->at(i);
			}
			delete trackSegmentCollection;
			trackSegmentCollection = new TrackSegmentCollection();
		}


	}

	void HoughTransformAlgorithm::AllocateHoughSpace() {

		houghSpaceX = new int *[thetaMax];
		for( int i=0 ;i<thetaMax ; i++ ) {
			houghSpaceX[i] = new int [rMax];
			for( int j=0 ;j<thetaMax ; j++ ) {
				houghSpaceX[i][j] = 0;
			}
		}

		houghSpaceY = new int *[thetaMax];
		for( int i=0 ;i<thetaMax ; i++ ) {
			houghSpaceY[i] = new int [rMax];
			for( int j=0 ;j<thetaMax ; j++ ) {
				houghSpaceY[i][j] = 0;
			}
		}


	}

	void HoughTransformAlgorithm::DeleteHoughSpace() {

		if( houghSpaceX != NULL ) {
			for(int i=0 ; i < thetaMax ; ++i) {
				delete [] houghSpaceX[i];
			}
			delete [] houghSpaceX;
		}

		if( houghSpaceY != NULL ) {
			for(int i=0 ; i < thetaMax ; ++i) {
				delete [] houghSpaceY[i];
			}
			delete [] houghSpaceY;
		}

	}

	void HoughTransformAlgorithm::End() {}

	Return HoughTransformAlgorithm::CheckConsistency() {

		return S_OK();
	}

/////////////////////////////////////////////////////////////////
//			 _____________________________________________
//			< Beginning of the main part of the algorithm >
//			 ---------------------------------------------
//				 \
//				  \
//				   ("`-'  '-/") .___..--' ' "`-._
//					 ` *_ *  )    `-.   (      ) .`-.__. `)
//					 (_Y_.) ' ._   )   `._` ;  `` -. .-'
//				  _.. `--'_..-_/   /--' _ .' ,4
//			   ( i l ),-''  ( l i),'  ( ( ! .-'
////////////////////////////////////////////////////////////////


	void HoughTransformAlgorithm::Execute() {

		clusterCollection = ClusteringManager::GetInstance()->GetCluster2D();
		HoughClusterCollection *houghClusterCollection = new HoughClusterCollection();

		for( unsigned int i=0 ; i<clusterCollection->size() ; i++ ) {

			Cluster *cluster = clusterCollection->at(i);
			if( cluster->GetClusterSize() > clusterSizeLimit ) continue;
			if( cluster->IsIsolatedFromClusters(clusterCollection) ) {

				HoughCluster *houghCluster = new HoughCluster();

				for( int t=0 ; t<thetaMax ; t++ ) {

					houghCluster->rhox.push_back( (int) abs( cluster->GetPosition().z() * cos(-M_PI/2.0 + t*M_PI/thetaMax)
									+ cluster->GetPosition().x() * sin(-M_PI/2.0 + t*M_PI/thetaMax) ) );
					houghCluster->rhoy.push_back( (int) abs( cluster->GetPosition().z() * cos(-M_PI/2.0 + t*M_PI/thetaMax)
									+ cluster->GetPosition().y() * sin(-M_PI/2.0 + t*M_PI/thetaMax) ) );
					houghSpaceX[ t ][ houghCluster->rhox.at( t ) ]++;

				}
				houghCluster->cluster = cluster;
				houghClusterCollection->push_back( houghCluster );
			}
		}


		for( int t=0 ; t<thetaMax ; t++ ) {
			for( unsigned int i=0 ; i<houghClusterCollection->size() ; i++ ) {

				HoughCluster *houghCluster = houghClusterCollection->at(i);
				if( houghSpaceX [ t ][ houghCluster->rhox.at(t) ] < minimumBinning ) continue;
				houghCluster->tagx = fGood;
				houghSpaceY[ t ][ houghCluster->rhox.at(t) ] ++;
			}
		}

		for( int t=0 ; t<thetaMax ; t++ ) {
			for( unsigned int i=0 ; i<houghClusterCollection->size() ; i++ ) {

				HoughCluster *houghCluster = houghClusterCollection->at(i);
				if( houghSpaceY [ t ][ houghCluster->rhoy.at(t) ] < minimumBinning ) continue;
				houghCluster->tagy = fGood;
			}
		}

		for( int t=0 ; t<thetaMax ; t++ ) {

			for( unsigned int i=0 ; i<houghClusterCollection->size() ; i++ ) {

				HoughCluster *houghCluster = houghClusterCollection->at(i);
				int inc = 0;

				for( unsigned int j=0 ; j<houghClusterCollection->size() ; j++ ) {

					HoughCluster *houghCluster2 = houghClusterCollection->at(j);

					if( houghCluster->cluster->GetPosition().z() == houghCluster2->cluster->GetPosition().z()
					 || houghCluster->rhox.at(t) - houghCluster2->rhox.at(t) != 0 )
						continue;

					if( houghCluster->tagx == fBad || houghCluster2->tagx == fBad )
						continue;

					if( abs( houghCluster2->cluster->GetPosition().x() - houghCluster->cluster->GetPosition().x() ) < deltaPosMax
					 && abs( houghCluster2->cluster->GetPosition().y() - houghCluster->cluster->GetPosition().y() ) < deltaPosMax
					 && abs( houghCluster2->cluster->GetPosition().z() - houghCluster->cluster->GetPosition().z() ) < deltaPosMax )
						inc++;

					if( inc < 2 ) continue;

					houghCluster->finalTag = fGood;
					houghCluster->cluster->SetClusterTagRecursive( fTrack );
				}
			}
		}


		HoughClusterCollection houghClusterTemp;

		for( unsigned int i=0 ; i<houghClusterCollection->size() ; i++ ) {

			HoughCluster *houghCluster = houghClusterCollection->at( i );
			if( houghCluster->finalTag != fGood ) continue;

			if( find(houghClusterTemp.begin()
									,houghClusterTemp.end()
									,houghCluster )
									!= houghClusterTemp.end() )
								continue;

			houghClusterTemp.push_back( houghClusterCollection->at( i ) );

			HoughClusterCollection tracks;
			tracks.push_back( houghClusterCollection->at( i ) );

			for(unsigned int j=0 ; j<houghClusterCollection->size() ; j++) {

				HoughCluster *houghCluster2 = houghClusterCollection->at( j );

				if( houghCluster2->finalTag != fGood ) continue;

				if( find(houghClusterTemp.begin()
						,houghClusterTemp.end()
						,houghCluster2 )
						!= houghClusterTemp.end() )
					continue;

				for( unsigned int k=0 ; k<tracks.size() ; k++ ) {

					HoughCluster *track = tracks.at(k);

					if( abs(track->cluster->GetPosition().z() - houghCluster2->cluster->GetPosition().z()) <= maximumDistanceBetweenHitsForLayers
					 && abs(track->cluster->GetPosition().y() - houghCluster2->cluster->GetPosition().y()) <= maximumDistanceBetweenHitsInPlane
					 && abs(track->cluster->GetPosition().x() - houghCluster2->cluster->GetPosition().x()) <= maximumDistanceBetweenHitsInPlane ) {

						tracks.push_back( houghClusterCollection->at( j ) );
						houghClusterTemp.push_back( houghClusterCollection->at( j ) );
						break;
					}
				}
			}

			if( tracks.size() < trackSegmentMinimumSize ) continue;
			TrackSegment *trackSegment = new TrackSegment();

			for(unsigned int j=0 ; j<tracks.size() ; j++) {
				HitCollection *hitColTemp = tracks.at(j)->cluster->GetHitCollection();
				for(unsigned int k=0 ; k<hitColTemp->size() ; k++ ) {
					trackSegment->AddHit( hitColTemp->at(k) );
					hitColTemp->at(k)->SetHitTag( fTrackSegment );
				}
			}

			trackSegment->GetExtremities().first->SetHitTag( fTrackExtremity );
			trackSegment->GetExtremities().second->SetHitTag( fTrackExtremity );
			trackSegmentCollection->push_back(trackSegment);
		}

	}

}


