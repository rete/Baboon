  /// \file EnergyMinimizer.cc
/*
 *
 * EnergyMinimizer.cc source template generated by fclass
 * Creation date : lun. d�c. 2 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : R�mi Et�
 * @version
 * @copyright
 *
 *
 */


#include "Reconstruction/EnergyMinimizer.hh"


namespace baboon {

	EnergyMinimizer *EnergyMinimizer::instance = 0;


	EnergyMinimizer::EnergyMinimizer() {

		minimizerType = "SIMPLEX";
		fitter = new TFitter();

		availableMinimizerTypes.push_back( "SIMPLEX" );
		availableMinimizerTypes.push_back( "MINUIT" );
		numberOfIteration = 3;
	}


	EnergyMinimizer::~EnergyMinimizer() {

		delete fitter;
	}


	EnergyMinimizer *EnergyMinimizer::GetInstance() {

		if( instance == 0 )
			instance = new EnergyMinimizer();
		return instance;
	}


	void EnergyMinimizer::Kill() {

		if( instance != 0 ) {
			delete instance;
			instance = nullptr;
		}
	}



	void EnergyMinimizer::SetMinimizerType( const std::string &type ) {

		minimizerType = type;
	}


	void EnergyMinimizer::AddParameter( const EnergyMinimizer::FitterParameter &param ) {

		bool found = false;
		for( unsigned int i=0 ; i<parameterList.size() ; i++ ) {
			if( parameterList.at(i).name == param.name ) {
				found = true;
				break;
			}
		}

		if( found )
			throw Exception( "EnergyMinimizer::AddParameter() : param name was already present" );

		// C++ 11 not available

//		auto it = std::find_if( parameterList.begin() , parameterList.end()
//				, [&]( FitterParameter &p ) -> bool { return (param.name == p.name); } );
//		if( it != parameterList.end() )
//			throw Exception( "EnergyMinimizer::AddParameter() : param name was already present" );

		parameterList.push_back( param );
	}

	void EnergyMinimizer::SetPrintOutLevel( double level ) {

		fitter->ExecuteCommand("SET PRINTOUT", &level , 1 );
	}



	void EnergyMinimizer::SetFunction( void (*func) (int& nDim , double* gout , double& result , double par[] , int flg) ) {

		if( func == nullptr )
			throw Exception( "EnergyMinimizer::SetFunction : function is a nullptr" );

		function = func;
	}


	void EnergyMinimizer::SetNumberOfIteration( int nbOfIt ) {

		if( nbOfIt > 0 )
			numberOfIteration = nbOfIt;
	}


	const std::vector<EnergyMinimizer::FitterParameter> &EnergyMinimizer::GetInputParameters() {

		return parameterList;
	}


	const std::vector<EnergyMinimizer::FitterParameter> &EnergyMinimizer::GetOutputParameters() {

		return outputParameterList;
	}




	void EnergyMinimizer::Minimize() {

		if( !Check() )
			throw Exception( "EnergyMinimizer::Minimize() : Couldn't minimize , parameter error" );

		fitter->SetFCN( function );

		outputParameterList.clear();
		outputParameterList = parameterList;
		std::vector< FitterParameter > tryParamsTemp = parameterList;
		std::vector< FitterParameter > newParamsTemp = parameterList;

		double min = 0.0;
		double *paramDouble = new double[ parameterList.size() ];

		for( int p=0 ; p<parameterList.size() ; p++ )
			paramDouble[p] = parameterList.at( p ).variable;

		int junk = 0;
		function( junk , nullptr , min , paramDouble , 0 );


		for( unsigned int it=0 ; it<numberOfIteration ; it++ ) {

			for( int p=0 ; p<tryParamsTemp.size() ; p++ ) {

				FitterParameter &param = tryParamsTemp.at(p);
				fitter->SetParameter( p , param.name.c_str() , param.variable , param.error , param.lowerValue , param.upperValue );
			}

			// Fitter call
			fitter->ExecuteCommand( minimizerType.c_str() , 0 , 0 );

			// Grab the output from the fitter ...
			for( int p=0 ; p<outputParameterList.size() ; p++ )
				paramDouble[p] = fitter->GetParameter( p );

			double newMin = 0.0;
			function( junk , nullptr , newMin , paramDouble , 0 );

			// ... and compare it with the previous minimization
			if( newMin < min ) {

				min = newMin;

				for( int p=0 ; p<outputParameterList.size() ; p++ )
					outputParameterList.at(p).variable = fitter->GetParameter( p );
			}

			tryParamsTemp = newParamsTemp;
		}

	}


	bool EnergyMinimizer::Check() {

		if( function == nullptr
		|| numberOfIteration <=0
		|| parameterList.empty()
		|| std::find( availableMinimizerTypes.begin() , availableMinimizerTypes.end() , minimizerType ) == availableMinimizerTypes.end() )
			return false;

		return true;
	}

}  // namespace 

