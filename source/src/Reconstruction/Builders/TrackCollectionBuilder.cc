  /// \file TrackCollectionBuilder.cc
/*
 *
 * TrackCollectionBuilder.cc source template generated by fclass
 * Creation date : mar. avr. 30 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Reconstruction/Builders/TrackCollectionBuilder.hh"



namespace baboon {





	TrackCollectionBuilder::TrackCollectionBuilder()
		: ObjectBuilder() {}

	TrackCollectionBuilder::~TrackCollectionBuilder() {

	}

	Return TrackCollectionBuilder::ClearObject() {

		if( object->empty() ) {
			delete object;
			return S_OK();
		}

		for( unsigned int i=0 ; i<object->size() ; i++ ) {
			delete object->at(i);
			object->at(i) = 0;
		}

		object->clear();
		delete object;

		return S_OK();
	}

	void TrackCollectionBuilder::BuildObject() {

		if( object != 0) ClearObject();

		object = new TrackCollection();

		ClusterCollection *clusterCollection = ClusteringManager::GetInstance()->GetCluster2D();

		ClusterCollection clusterTemp;

		for( unsigned int i=0 ; i<clusterCollection->size() ; i++ ) {

			Cluster *cluster = clusterCollection->at( i );
			if( cluster->GetClusterTag() != fTrack ) continue;

			if( find(clusterTemp.begin()
									,clusterTemp.end()
									,cluster )
									!= clusterTemp.end() )
								continue;

			clusterTemp.push_back( clusterCollection->at( i ) );

			ClusterCollection trackClusters;
			trackClusters.push_back( clusterCollection->at( i ) );

			for(unsigned int j=0 ; j<clusterCollection->size() ; j++) {

				Cluster *cluster2 = clusterCollection->at( j );

				if( cluster2->GetClusterTag() != fTrack ) continue;

				if( find(clusterTemp.begin()
						,clusterTemp.end()
						,cluster2 )
						!= clusterTemp.end() )
					continue;

				for( unsigned int k=0 ; k<trackClusters.size() ; k++ ) {

					Cluster *track = trackClusters.at(k);

					if( abs( cluster->GetPosition().z() - cluster2->GetPosition().z() ) <= maximumDistanceBetweenHitsForLayers
					 && abs( cluster->GetPosition().y() - cluster2->GetPosition().y() ) <= maximumDistanceBetweenHitsInPlane
					 && abs( cluster->GetPosition().x() - cluster2->GetPosition().x() ) <= maximumDistanceBetweenHitsInPlane ) {

						trackClusters.push_back( clusterCollection->at( j ) );
						clusterTemp.push_back( clusterCollection->at( j ) );
						break;
					}
				}
			}

			if( trackClusters.size() < trackSegmentMinimumSize ) continue;
			Track *track = new Track();

			for(unsigned int j=0 ; j<trackClusters.size() ; j++) {
				HitCollection *hitColTemp = trackClusters.at(j)->GetHitCollection();
				for(unsigned int k=0 ; k<hitColTemp->size() ; k++ ) {
					track->AddHit( hitColTemp->at(k) );
					hitColTemp->at(k)->SetHitTag( fTrack );
				}
			}

			track->GetExtremities().first->SetHitTag( fTrackExtremity );
			track->GetExtremities().second->SetHitTag( fTrackExtremity );
			object->push_back( track );
		}


	}



	// template initialization
	template ObjectBuilder<TrackCollection>::ObjectBuilder();


}  // namespace 

