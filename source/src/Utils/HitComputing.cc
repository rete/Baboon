  /// \file HitComputing.cc
/*
 *
 * HitComputing.cc source template generated by fclass
 * Creation date : dim. avr. 21 2013
 * Copyright (c) CNRS , IPNL
 *
 * All Right Reserved.
 * Use and copying of these libraries and preparation of derivative works
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * @author : rete
 */


#include "Utils/HitComputing.hh"


using namespace std;



namespace sdhcal {



	Hit *GetClosestHit( const ThreeVector &v , HitCollection *hitCol ) {

		if( hitCol->size() == 0 ) return 0;
		Hit *closestHit = hitCol->at(0);

		for( unsigned int i=1 ; i<hitCol->size() ; i++ )
			if( (hitCol->at(i)->GetPosition() - v ).mag() < (closestHit->GetPosition() - v ).mag() )
				closestHit = hitCol->at(i);

		return closestHit;
	}

	ThreeVector GetCenterOfGravity( HitCollection * hitCol ) {

		ThreeVector weightVec(0,0,0);
		ThreeVector centOfGrav(0,0,0);
		ThreeVector sumWeightVec(0,0,0);

		for (int j=0 ; j<hitCol->size() ; j++) {

			Hit *hit = hitCol->at(j);
			IntVec ijkVec = hit->GetIJK();
			HitThreshold fThr = hit->GetThreshold();

			if( fThr == fThreshold3 )      weightVec.set(3,3,3);
			else if( fThr == fThreshold2 ) weightVec.set(2,2,2);
			else if( fThr == fThreshold1 ) weightVec.set(1,1,1);

			centOfGrav.set( centOfGrav.x() + weightVec.x()*ijkVec.at(0)
							,centOfGrav.y() + weightVec.y()*ijkVec.at(1)
							,centOfGrav.z() + weightVec.z()*ijkVec.at(2) );

			sumWeightVec.set(sumWeightVec.x()+weightVec.x()
							,sumWeightVec.y()+weightVec.y()
							,sumWeightVec.z()+weightVec.z());
		}

		centOfGrav.setX( centOfGrav.x()/sumWeightVec.x() );
		centOfGrav.setY( centOfGrav.y()/sumWeightVec.y() );
		centOfGrav.setZ( centOfGrav.z()/sumWeightVec.z() );

		centOfGrav.setX( round( centOfGrav.x() ) );
		centOfGrav.setY( round( centOfGrav.y() ) );
		centOfGrav.setZ( round( centOfGrav.z() ) );

		return centOfGrav;
	}


	ThreeVector GetCenterOfGravity( LCCollection *lcCollection ) {

		ThreeVector weightVec(0,0,0);
		ThreeVector centOfGrav(0,0,0);
		ThreeVector sumWeightVec(0,0,0);

		for (int j=0; j<lcCollection->getNumberOfElements(); ++j) {
			IMPL::CalorimeterHitImpl *hitImpl = static_cast<IMPL::CalorimeterHitImpl*> ( lcCollection->getElementAt(j) );
			Hit *hit = new Hit(hitImpl);

			IntVec cell = hit->GetIJK();

			float fThr = hit->getEnergy();

			if(fThr>=2.5)      weightVec.set(3,3,3);
			else if(fThr>=1.5) weightVec.set(1,1,1);
			else if(fThr>=0.5) weightVec.set(2,2,2);
			centOfGrav.set( centOfGrav.x() + weightVec.x()*cell.at(0)
							,centOfGrav.y() + weightVec.y()*cell.at(1)
							,centOfGrav.z() + weightVec.z()*cell.at(2) );

			sumWeightVec.set(sumWeightVec.x()+weightVec.x()
							,sumWeightVec.y()+weightVec.y()
							,sumWeightVec.z()+weightVec.z());

			delete hit;
		}

		centOfGrav.setX( centOfGrav.x()/sumWeightVec.x() );
		centOfGrav.setY( centOfGrav.y()/sumWeightVec.y() );
		centOfGrav.setZ( centOfGrav.z()/sumWeightVec.z() );

		centOfGrav.setX( round( centOfGrav.x() ) );
		centOfGrav.setY( round( centOfGrav.y() ) );
		centOfGrav.setZ( round( centOfGrav.z() ) );

		return centOfGrav;
	}


	double GetRMSDispersion( HitCollection *hitCol ) {

		ThreeVector cog = GetCenterOfGravity(hitCol);
		double rms = 0;

		for( unsigned int i=0 ; i<hitCol->size() ; i++ ) {
			IntVec ijk = hitCol->at(i)->GetIJK();
			rms += (cog.x()-ijk.at(0))*(cog.x()-ijk.at(0)) + (cog.y()-ijk.at(1))*(cog.y()-ijk.at(1));
		}
		if(hitCol->size() == 0) return 0;
		return sqrt(rms/hitCol->size());
	}



}  // namespace 

