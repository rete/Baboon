  /// \file Connector.hh
/*
 *
 * Connector.hh header template generated by fclass
 * Creation date : jeu. oct. 10 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Et� R�mi
 * @version
 * @copyright
 *
 *
 */


#ifndef CONNECTOR_HH
#define CONNECTOR_HH

#include <iostream>
#include <string>
#include <cstdlib>
#include <cmath>
#include <vector>
#include <utility>
#include <algorithm>

#include "Objects/CaloHit.hh"


#define MACRO_TEMPLATE_INIT_POINT( typeT , typeS )																	 \
{                                                                                                                    \
	template baboon::Point< typeT , typeS >::Point();																 \
}
//	template baboon::Point< typeT , typeS >::~Point();																	 \
//	template void baboon::Point< typeT , typeS >::AddConnector( baboon::Connector< typeT , typeS > *connector );       \
//	template void baboon::Point< typeT , typeS >::RemoveConnector( baboon::Connector< typeT , typeS > *connector );    \
//	template bool baboon::Point< typeT , typeS >::IsConnectedTo( baboon::Connector< typeT , typeS > *connector );      \
//	template bool baboon::Point< typeT , typeS >::IsConnectedTo( Point< typeS , typeT > *point );                      \
//	template void baboon::Point< typeT , typeS >::SetObject( typeT *obj );                                             \
//	template typeT *baboon::Point< typeT , typeS >::GetObject();                                                        \
//	template typename ConnectorCollection< typeT , typeS >::type &baboon::Point< typeT , typeS >::GetConnectors();     \
//}

//	template baboon::Point< typeT , typeS >::Point();
//	template baboon::Point< typeT , typeS >::~Point();
//	template void baboon::Point< typeT , typeS >::AddConnector( baboon::Connector< typeT , typeS > *connector );
//	template void baboon::Point< typeT , typeS >::RemoveConnector( baboon::Connector< typeT , typeS > *connector );
//	template bool baboon::Point< typeT , typeS >::IsConnectedTo( baboon::Connector< typeT , typeS > *connector );
//	template bool baboon::Point< typeT , typeS >::IsConnectedTo( Point< typeS , typeT > *point );
//	template void baboon::Point< typeT , typeS >::SetObject( typeT *obj );
//	template typeT *baboon::Point< typeT , typeS >::GetObject();
//	template typename ConnectorCollection< typeT , typeS >::type &baboon::Point< typeT , typeS >::GetConnectors();


//#define MACRO_TEMPLATE_INIT_CONNECTOR( typeT , typeS )          \\
//{
//	template
//}


namespace baboon {

	// forward declaration of Connector class
	template<typename T, typename S>
	class Connector;

	// forward declaration of Point class
	template<typename T, typename S>
	class Point;

	// forward declaration of ConnectorCollection typedef
	template<typename T,typename S>
	struct ConnectorCollection {
		 typedef std::vector< Connector<T,S> * > type;
	};

	// forward declaration of PointPair typedef
	template<typename T,typename S>
	struct PointPair{
		typedef std::pair< Point<T,S> * , Point<S,T> * > type;
	};


	/*!
	 *
	 * @brief Point class
	 *
	 */
	template<typename T,typename S>
	class Point {

		public:

			/*!
			*
			* @brief  Default constructor
			*
			*/
			Point();

			/*!
			*
			* @brief  Default destructor
			*
			*/
			virtual ~Point();

			/*!
			 *
			 *
			 *
			 */
			void AddConnector( Connector<T,S> *connector );

			/*!
			 *
			 *
			 *
			 */
			void RemoveConnector( Connector<T,S> *connector );

			/*!
			 *
			 *
			 *
			 */
			bool IsConnectedTo( Connector<T,S> *connector );

			/*!
			 *
			 * @brief Return true if the point is connected to 'point'
			 *
			 */
			bool IsConnectedTo( Point<S,T> *point );

			/*!
			 *
			 * Set the object
			 *
			 */
			void SetObject( T obj );

			/*!
			 *
			 * @brief Return the object
			 *
			 */
			T GetObject();

			/*!
			 *
			 * @brief Return true if there is no connection
			 *
			 */
			bool HasNoConnection();

			/*!
			 *
			 *  @brief Return the connectors
			 *
			 */
			typename ConnectorCollection< T , S >::type &GetConnectors();

		protected:

			typename ConnectorCollection< T , S >::type connectors;          ///< The connectors
			T object;                                     	                   ///< The associated object

	};

	/*!
	 *
	 * @brief Connector class.
	 *
	 */
	template<typename T,typename S>
	class Connector {

		public:

			/*!
			 *
			 * @brief Default constructor
			 *
			 */
			Connector();

			/*!
			 *
			 * @brief Default destructor
			 *
			 */
			~Connector();

			/*
			 *
			 * @brief Connects two points
			 *
			 */
			void Connect( Point<T,S> *point1 , Point<S,T> *point2 );

			/*!
			 *
			 * @brief Disconnect the two points
			 *
			 */
			void Disconnect();

			/*!
			 *
			 * @brief Return the first connected point
			 *
			 */
			Point<T,S> *GetFirst();

			/*!
			 *
			 * @brief Return the second connected point
			 *
			 */
			Point<S,T> *GetSecond();


		protected:

			typename PointPair<T,S>::type pointPair;    ///< The point pair that are connected

	}; // class

}  // namespace 

#endif  //  CONNECTOR_HH
