  /// \file TrackFinderAlgorithm.hh
/*
 *
 * TrackFinderAlgorithm.hh header template generated by fclass
 * Creation date : mar. oct. 8 2013
 *
 * This file is part of XXX libraries.
 * 
 * XXX is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * XXX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with XXX.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author : Et� R�mi
 * @version
 * @copyright
 *
 *
 */


#ifndef TRACKFINDERALGORITHM_HH
#define TRACKFINDERALGORITHM_HH

#include "Algorithm/AbstractAlgorithm.hh"

#include <iostream>
#include <string>
#include <cstdlib>
#include <cmath>
#include <vector>
#include <utility>


// baboon includes
#include "Objects/Cluster.hh"
#include "Managers/ClusteringManager.hh"
#include "Detector/Calorimeter.hh"
#include "Managers/TrackManager.hh"
#include "Monitoring/BaboonMonitoring.hh"

// root includes
#include "TEveArrow.h"

namespace baboon {

	class Cluster;
	class Calorimeter;

	/*!
	*
	* @brief  TrackFinderAlgorithm class
	* Inherits from base class AbstractAlgorithm
	*
	*/
	class TrackFinderAlgorithm : public AbstractAlgorithm {

		public:

			class Connector;
			typedef std::vector<Connector *> ConnectorCollection;

			/*!
			 *
			 * @brief Point class.
			 *
			 */
			class Point {


				public:

					/*!
					 *
					 * @brief Constructor
					 *
					 */
					Point();

					/*!
					 *
					 * @brief Destructor
					 *
					 */
					~Point();

					/*!
					 *
					 * @brief Add a connector to this point
					 *
					 */
					void AddConnector( Connector *connector );

					/*!
					 *
					 * @brief Remove a connector from this point
					 *
					 */
					void RemoveConnector( Connector *connector );

					/*!
					 *
					 * @brief Return true if the point has the given connector
					 *
					 */
					bool IsConnectedTo( Connector *connector );

					/*!
					 *
					 * @brief Return true if the point is connected to 'point'
					 *
					 */
					bool IsConnectedTo( Point *point );

					/*!
					 *
					 * Set the cluster
					 *
					 */
					void SetCluster( Cluster *cluster );

					/*!
					 *
					 * @brief Return the cluster
					 *
					 */
					Cluster *GetCluster();

					/*!
					 *
					 * @brief Return true if there is no connection
					 *
					 */
					bool HasNoConnection();

					/*!
					 *
					 * @brief Return the connectors
					 *
					 */
					ConnectorCollection *GetConnectors();

					/*!
					 *
					 * @brief Return the number of backward connectors ie. the number of
					 * connectors that verify "connectorLayer < clusterLayer"
					 *
					 */
					int HowManyBackwardConnectors();

					/*!
					 *
					 * @brief Return the number of forward connectors ie. the number of
					 * connectors that verify "connectorLayer > clusterLayer"
					 *
					 */
					int HowManyForwardConnectors();


				protected:

					std::vector<Connector *> *connectors;          ///< The connectors
					Cluster *cluster;                              ///< The associated cluster
			};

			typedef std::vector<Point *> PointCollection;
			typedef std::map<unsigned int,PointCollection *> OrderedPointCollection;

			/*!
			 *
			 * @brief Connector class.
			 *
			 */
			class Connector {

				public:

					/*
					 *
					 * @brief Connects two points
					 *
					 */
					void Connect( Point *point1 , Point *point2 );

					/*!
					 *
					 * @brief Disconnect the two points
					 *
					 */
					void Disconnect();

					/*!
					 *
					 * @brief Return the first connected point
					 *
					 */
					TrackFinderAlgorithm::Point *GetFirst();

					/*!
					 *
					 * @brief Return the second connected point
					 *
					 */
					TrackFinderAlgorithm::Point *GetSecond();


				protected:

					std::pair<Point*,Point*> pointPair;    ///< The point pair that are connected

			};

			/*!
			 *
			 * @brief A helper class for recursive method FindPotentialTrack()
			 *
			 */
			class PointHelper {

				public:
					Point *point;                                   ///< The point containing the cluster
					Point *forwardPoint;							///< The next point if the connection is forced
					bool isFirstPoint;								///< True if 'point' is the first one passed to the function
					PointCollection *pointCollection;				///< The point collection cluster while building the potential track
					Connector *forwardConnector;					///< The forced connector if there is one
			};

			typedef std::vector<PointHelper *> PointHelperCollection;

			/*!
			*
			* @brief  Default constructor
			*
			*/
			TrackFinderAlgorithm();

			/*!
			*
			* @brief  Default destructor
			*
			*/
			virtual ~TrackFinderAlgorithm();

			/*!
			 *
			 * @brief Set the calorimeter to use
			 *
			 */
			void SetCalorimeter( Calorimeter *calo )
				{ calorimeter = calo; }



		protected:

			/*!
			 *
			 * @brief Initialize the algorithm, i.e by initializing specific variables
			 *
			 */
			virtual Return Init();


			/*!
			 *
			 * @brief Execute the algorithm
			 *
			 */
			virtual Return Execute();


			/*!
			 *
			 * @brief Finalize the algorithm
			 *
			 */
			virtual Return End();


			/*!
			 *
			 * @brief Allow to check if everything is well set in the algorithm before starting it
			 *
			 */
			virtual Return CheckConsistency();

			/*!
			 *
			 * @brief First cut applied on a 2D cluster
			 * to decide whether or not it can belongs to a track
			 *
			 */
			bool KeepCluster( Cluster *cluster , ClusterCollection *clusterCollection );

			/*!
			 *
			 * @brief Find points in the Nth layer after the given point in the region of interest
			 * and create some connections with them.
			 * Return true if at least one point was connected
			 *
			 */
			bool ConnectWithLayer( Point *point , PointCollection *pointCollection );

			/*!
			 *
			 * @brief Recursive function that look for a track starting from the
			 * point which is contained in the cluster helper ( point ).
			 * At the first iteration, it loops over all the connectors of the
			 * point and find the best aligned connector. A cut is applied if the angle
			 * is too big. If something is found, it runs again the function on
			 * the next point.
			 *
			 */
			void FindPotentialTrack( PointHelper *pointHelper );

			/*!
			 *
			 * @brief Sort the potential tracks by size
			 *
			 */
			void SortPotentialTracksBySize();

			/*!
			 *
			 * @brief Helper method to sort the points by layer ID (from backward to forward)
			 *
			 */
			void SortPointsByLayer( PointCollection *pointCollection );

			/*!
			 *
			 * @brief Helper method to draw the track with its connectors
			 *
			 */
			void DrawTrackConnectors( PointCollection *trackPoints , int color );

			/*!
			 *
			 * @brief Helper method to draw one connector
			 *
			 */
			void DrawEveArrow( double I1 , double J1 , double K1 ,
								double I2 , double J2 , double K2 ,
								int color );


			Calorimeter *calorimeter;						      ///< The calorimeter instance
			PointCollection *allPoints;        		  		      ///< All the points that can be connected
			PointHelperCollection *pointHelpers;  	              ///< The cluster helper collection
			std::vector<PointCollection *> potentialTrackPoints;  ///< The potential tracks
			ConnectorCollection *connectorCollection;             ///< All the connectors. Just for memory management...

			// Algorithm parameters
			int clusterSizeLimit;         			  ///< The cluster size limit contained in a track
			int minimumTrackSize;      			      ///< The track minimum size
			int lookupDistanceX;       			      ///< The maximum distance between two connection in X direction
			int lookupDistanceY;       			      ///< The maximum distance between two connection in Y direction
			int lookupDistanceZ;					  ///< The maximum distance between two connection in Z direction
			double maximumConnectorsAngle;			  ///< The maximum angle between two consecutive connectors inside a track

	};  // class

}  // namespace 

#endif  //  TRACKFINDERALGORITHM_HH
